{"pages":[{"title":"UDOO Quad\/Dual Docs","text":"","tags":"","url":"index.html"},{"title":"Introduction","text":"UDOO DUAL\/QUAD UDOO DUAL\/QUAD is a single board computer that can run Android or Linux OS, and also features an Arduino-compatible microcontroller embedded onboard. It is a powerful prototyping board for software development and design. Easy to use, it allows to develop projects with minimum knowledge of hardware design. UDOO DUAL\/QUAD merges different computing worlds together: each one has its proper strengths and weak points, but all of them are useful in todays life for educational purposes as well as Do-It-Yourself (DIY) and quick prototyping. UDOO DUAL\/QUAD is an open hardware, low-cost platform equipped with an ARM i.MX6 NXP\u00ae processor, and an Arduino Due compatible section based on ATMEL SAM3X8E ARM processor, all this available on the same board! UDOO DUAL\/QUAD Goals: Develop an innovative product for a growing market Give a new vision to the educational framework, with the idea of training up a new generation of engineers, designers and software developers skilled in digital technology: physical computing, multi-media arts, interactive arts, IoT... Give a boost to the DIY world Offer a low cost embedded platform for interactive arts with powerful tools: Processing, OpenCV, PureData, openFramework Provide companies with a great tool for fast prototyping Specifications UDOO DUAL\/QUAD retail line up consists of three models, sharing most of the features and different only for connectivity and i.MX6 processor used. All three models feature an embedded Arduino compatible section based on Arduino Due schematic. UDOO DUAL\/QUAD\u2019s dimensions are: 4.33 inch x 3.35 inch (11 cm x 8.5 cm). NXP\u00ae i.MX6Quad, 2\\4 x ARM\u00ae Cortex\u2122-A9 core @ 1GHz with ARMv7A instruction set GPU Vivante GC 2000 for 3D + Vivante GC 355 for 2D (vector graphics) + Vivante GC 320 for 2D Atmel SAM3X8E ARM Cortex-M3 CPU (same as Arduino Due) RAM DDR3 1GB 76 fully available GPIO with Arduino compatible R3 1.0 pinout HDMI and LVDS + Touch 2 Micro USB (1 OTG) 2 USB 2.0 type A and 1 USB 2.0 internal pin header (requires adapter cable) Analog Audio and Mic jacks CSI Camera Connection on board Micro SD card reader (boot device) Power Supply (6-15V DC) and External Battery connector Gigabit Ethernet RJ45 (10\/100\/1000 MBit) WiFi Module SATA connector with power header Warning: The UDOO DUAL\/QUAD I\/O pins are 3.3V compliant. Higher voltages (like 5V) would damage the board. Here you can find a more technical and exhaustive document, the UDOO QUAD\/DUAL\u2019s block diagram. GPIO Features 76 fully available GPIO Arduino-compatible R3 1.0 pinout 3,3 V Compliant Compatible with All Arduino Due Shields and most Arduino Shields GPIO's can be accessed as Arduino pins, GPIO's or as additional S\\PDIF, FlexCAN,I2S, SPI More information about UDOO DUAL\/QUAD_GPIO_Pinout Official Accessories UDOO Camera Module Auto focus control (AFC) with embedded AF VCM driver Sensitivity: 600mV\/lux-sec Video capture in Full Field of View (FOV): double sensitivity,improved signal-to.noise ratio (SNR) Post-binning re-sampling filter for sharper, crisper contours and colours Internal anti-shaking engine Image transfer rate VGA (320x480) @120fps VGA (640x480) @90fps 720p @60fps 1280x960 @45fps 1080p @30fps QSXGA (2592x1944) @15fps More informations about UDOO Camera Modules UDOO Camera Module Datasheet UDOO LVDS Touch Screens 7&quot; Touch Panel Kit 7&quot; TFT RGB Display I2C Touch Screen Dual Touch Resolution 800X480 UDOO_VK-7T video cable for UDOO LCD BOARD ADAPTER How to setup LVDS panels UDOO 7&quot; Touch Panel Display Kit Datasheet 15&quot; Touch Panel Kit 15,6&quot; LVDS Display USB Capacitive Touch Screen Resolution 1366X768 24bit UDOO_VK-15T video cable for UDOO USB CABLE for Third UDOO'USB Touch Controller Board How to setup LVDS panels UDOO 15&quot; Touch Panel Display Kit Datasheet Community Official web site www.udoo.org Official forum www.udoo.org\/forum Forums The official UDOO forums can be found at www.udoo.org\/forum The forum search facility has been tweaked to allow more general searching. Please do a search before making a post as the issue may already have been raised and answered. IRC channel There is an (unofficial) UDOO discussion channel on IRC. Using the IRC client of your choice, use server information: irc.freenode.net. Room name is #udoo. Social networks Facebook fan page Twitter Google+ YouTube","tags":"","url":"Introduction\/Introduction.html"},{"title":"Very First Start","text":"Overview This easy step by step guide will lead you through the procedure to boot your UDOO DUAL\/QUAD for the very first time. You can also watch our connectivity walkthrough. Step by step procedure 1. Insert the micro SD card UDOO DUAL\/QUAD has no internal storage or built-in boot code, OS and storage are on microSD so you need to plug a pre-loaded microSD to boot. If you didn\u2019t get a pre-loaded microSD card, you should follow our step by step guide about creating a bootable Micro SD card from precompiled image. 2. Connect the HDMI cable UDOO DUAL\/QUAD features full HD video output on standard HDMI connector. Plug your full-size \u2018male\u2019 HDMI cable to UDOO DUAL\/QUAD, then plug it to your monitor or digital TV. 3. Connect network (optional) If you want, you can plug your RJ-45 ethernet cable now, but you can do it later when the board is booted or you can just use the WiFi to connect wirelessly to your network. 4. Connect input Every keyboard and mouse should work with UDOO DUAL\/QUAD. The board provides 5V 500mAmp so you don\u2019t need an USB hub unless you need to power up high power consumption devices. Wireless keyboard\/mouse should work as well. 5. Power up UDOO DUAL\/QUAD starter kits and pre-orders come with a 12V and 2Amp switching DC supply with a standard 5.5mm\/2.1mm barrel jack. This supply is designed to work anywhere in the world, 100V-240V AC wall power but you may need a plug adapter. UDOO DUAL\/QUAD will boot as soon as you connect the power supply. You\u2019re now good to go to start explore, learn and make with your UDOO DUAL\/QUAD board!","tags":"","url":"Getting_Started\/Very_First_Start.html"},{"title":"Create A Bootable MicroSD card for UDOO QUAD-DUAL","text":"Overview The following paragraphs will guide you through the creation of a bootable Micro SD card for UDOO QUAD\/DUAL, starting from a precompiled image file containing the UDOObuntu 2 or Android Lollipop Operating system, which runs on the i.MX6 processor. The procedure is quite easy: simply unzip the image and write it on the Micro SD card using the dd tool for UNIX\/MAC users or Win32DiskImager for Windows users. It is not possible to create a bootable Micro SD card with drag and drop. SD Card Requirements Please consider that the size of a Micro SD card must be at least 4\/8GB (depending on the operating system); Micro SD memory cards with a higher capacity (tested up to 64GB) may be used, and the Linux root partition will be expanded to the full SD card size during the first boot. Android images are not expanded and stuck at 4GB even if you use a bigger SD card; however you can expand your \/data partition manually using UDOO Settings. OS Minimum SD size Maximum SD size Automatic expansion UDOObuntu Linux 4GB 64GB Yes Android 8GB 64GB No Step by Step Guide Download any official Micro SD image from the image section of the website. Extract the .img file from the .zip file you downloaded into any folder (this path will be referred to as &lt;img_file_path&gt; in the guide). Follow the instructions below for the OS you use: Windows Mac OS X Linux Extract the downloaded zip file, so you'll have a .img image file. Do not use the preinstalled archive extractor, use 7-zip or similar to decompress the zip file. Download the Win32DiskImager software and unzip it. If your PC has a slot for SD cards (you may need a Micro SD to SD adapter), simply insert the card. If not, insert the card into any SD card reader and then connect it to the PC. Run the file named Win32DiskImager.exe right-clicking it and selecting \u201cRun as administrator\u201d. If the Micro SD card (Device) used is not detected automatically, click on the drop down box on the right and select the identifier of the Micro SD card that has been plugged in (e.g. [H:]). If your Micro SD card is not listed, try to format it using the FAT32 file system. Heads up! Please be careful to select the correct drive identifier; if you use the wrong identifier you may lose all data in your PC! In the Image File box, choose the downloaded .img file and click \u201cWrite\u201d. Click yes in case a warning message pops up. The Micro SD card is now ready to be used. Simply insert it in the board\u2019s Micro SD Card slot and boot the system. If you have problems, have a look to the video tutorial Creating a bootable MicroSD card using Windows from image. From the Terminal app run df -h If your Mac has a slot for SD cards (you may need a Micro SD to SD adapter), simply insert the card. If not, insert the card into any SD card reader and then connect it to the Mac. Run again df -h The device that wasn't listed before is the Micro SD card just inserted. The name shown will be the one of the filesystem\u2019s partition, for example, \/dev\/disk3s1. Now consider the raw device name for using the entire disk, by omitting the final s1 and replacing disk with rdisk (considering the previous example, use rdisk3, not disk3 nor rdisk3s1). Heads up! Please be careful to select the correct device identifier; if you use the wrong identifier you may lose all data in your Mac! Unmount all the partitions in the SD card (use the correct name found previously, followed by letters and numbers that identify the partitions). using diskutil: sudo diskutil unmount \/dev\/disk3s1 Now write the image on the Micro SD card using the command: sudo dd bs=1m if=&lt;img_file_path&gt; of=\/dev\/&lt;sd_name&gt; Please make sure that you replaced the argument of input file (if=&lt;img_file_path&gt;) with the path to the .img file, and that the device name specified in output file\u2019s argument (of=\/dev\/&lt;sd_name&gt;) is correct. Please also make sure that the device name is the one of the whole Micro SD card as described above, not just a partition (for example, rdisk3, not disk3s1). For example: sudo dd bs=1m if=\/Users\/YourName\/Download\/udoobuntu-udoo-qdl_v2.0.img of=\/dev\/rdisk3 Once dd has been completed, run: sudo sync sudo diskutil eject \/dev\/rdisk3 The Micro SD card is now ready to be used. Simply insert it in the board\u2019s Micro SD Card slot and boot the system. If you have problems, have a look to the video tutorial Creating a bootable MicroSD card with Mac OSX from image. From the terminal run df -h If your PC has a slot for SD cards (you may need a Micro SD to SD adapter), simply insert the card. If not, insert the card into any SD card reader and then connect it to the PC. Run again df -h The device that wasn't listed before is the Micro SD card just inserted. The left column will show the device name assigned to the Micro SD card. It will have a name similar to \/dev\/mmcblk0p1 or \/dev\/sdd1. The last part of the name (p1 or 1, respectively) is the partition number, but it is necessary to write on the whole Micro SD card, not only on one partition. Therefore, it is necessary to remove that part from the name (for example \/dev\/mmcblk0 or \/dev\/sdd) in order to work with the whole Micro SD card. Heads up! Please be careful to select the correct device identifier; if you use the wrong identifier you may lose all data in your PC! Unmount all the partitions in the SD card (use the correct name found previously, followed by letters and numbers that identify the partitions). using umount: sudo umount \/dev\/sdd1 Now write the image on the Micro SD card using the command: sudo dd bs=1M if=&lt;img_file_path&gt; of=\/dev\/&lt;sd_name&gt; Please make sure that you replaced the argument of input file (if=&lt;img_file_path&gt;) with the path to the .img file, and that the device name specified in output file\u2019s argument (of=\/dev\/&lt;sd_name&gt;) is correct. For example: sudo dd bs=1m if=\/home\/YourName\/Download\/udoobuntu-udoo-qdl_v2.0.img of=\/dev\/sdd Once dd has been completed, run: sudo sync The Micro SD card is now ready to be used. Simply insert it in the board\u2019s Micro SD Card slot and boot the system. If you have problems, have a look to the video tutorial Creating a bootable MicroSD card with Linux Ubuntu from image.","tags":"","url":"Getting_Started\/Create_A_Bootable_MicroSD_card_for_UDOO_QUAD_DUAL.html"},{"title":"Connecting Via Serial Cable","text":"Overview Visit our Tutorials section to learn more about: Connecting Via Serial Cable. UDOO DUAL\/QUAD features a built in USB to serial interface which is very useful for various reasons: You can use it to connect UDOO DUAL\/QUAD via SSH without a network connection, programming the Sam3x (arduino) and access the debug console for troubleshooting purposes. Connecting via serial will practically result in a shell console, the same as the one you\u2019ll obtain through SSH connection http:\/\/en.wikipedia.org\/wiki\/Secure_Shell. Windows Mac OS X Linux Connecting via Serial from Windows Download the serial adapter Driver here: http:\/\/www.silabs.com\/products\/mcu\/pages\/usbtouartbridgevcpdrivers.aspx Install the proper version for your Operating system: CP210xVCPInstaller_x86.exe for 32-bit systems CP210xVCPInstaller_x64.exe for 64-bit system How to define your Windows version: http:\/\/windows.microsoft.com\/en-us\/windows7\/32-bit-and-64-bit-windows-frequently-asked-questions Download and install a software called putty http:\/\/www.chiark.greenend.org.uk\/~sgtatham\/putty\/download.html Open putty and configure it as follow: Connection type \u201cserial\u201d Port: \u201cCOM3\u201d (please note that this value may be different, check the number of the COM assigned in Windows Device Manager) Speed: \u201c115200\u201d Save it as \u201cUdoo-serial\u201d for future uses. Connect the serial port of UDOO DUAL\/QUAD (CN6) to your PC using the micro USB cable. Power up UDOO DUAL\/QUAD Click Open You\u2019re in! You\u2019ll be able to see the startup process and access to the remote shell console on UDOO DUAL\/QUAD. Connecting via Serial from Linux Connect the serial port of UDOO DUAL\/QUAD (CN6) to your PC using the micro USB cable. Type dmesg You should see this line at the end usb 2-2.1: cp21x converter now attached to tty Install minicom: sudo apt-get update sudo apt-get install minicom Open Minicom and configure it (only the first time) using the following command: sudo minicom -sw Go to \u201cSerial port setup\u201d and edit as follow: Serial Device: \/dev\/ttyUSB0 (type a key) Hardware Flow Control: No (type f key) Software Flow Control: No (type g key) Press exit and &quot;Save setup as dfl&quot; Exit from Minicom Let\u2019s give proper access permissions to serial port with: sudo chmod 666 \/dev\/ttyUSB0 Now we can start listening with: sudo minicom -w Power cycle UDOO DUAL\/QUAD to see the boot process and connect it to serial console shell Connecting via Serial from Mac Download the serial adapter Driver here: http:\/\/www.silabs.com\/products\/mcu\/pages\/usbtouartbridgevcpdrivers.aspx Connect the serial port of UDOO DUAL\/QUAD (CN6) to your PC using the micro USB cable. Download and install Serial Tools https:\/\/itunes.apple.com\/it\/app\/serialtools\/id611021963 or directly from the Apple Store Open Serial Tools, and change the following parameters: Serial Port: \u201cSLEB_USBtoUART\u201d Baud rate \u201c115200\u201d Hit connect, and here you go!","tags":"","url":"Basic_Setup\/Connecting_Via_Serial_Cable.html"},{"title":"Find IP Address","text":"Overview We\u2019ll find out how to discover the IP address associated with your UDOO DUAL\/QUAD. The IP address is a number that uniquely identifies a device in a network. It will be useful to know which IP your UDOO DUAL\/QUAD is assigned to for various reasons: connecting to it remotely, knowing wheter UDOO DUAL\/QUAD is booting properly or not and configure it to interact correctly into a given network. We\u2019ll have various way to find the IP Address, so let\u2019s get started. First method: Command Line If your UDOO QUAD\/DUAL is connected to a screen (or via serial cable like explained in the previous page), you can simply open a terminal and type: sudo ifconfig -a This command will output informations related to both Ethernet and Wi-Fi status, including respective IP addresses. Second method: use the FING app Fing is a network scanner app, which will help you to discover every device connected into your network. Simply go to the Android or Ios market, download and launch it. If UDOO DUAL\/QUAD is properly connected to the same network your phone is (wheter via Wi-Fi or ethernet), you should see it and discover its IP address. As you can see, UDOO DUAL\/QUAD is identified as: Shenzen Ogemray Technology. Third method: use your router\u2019s control pane Just connect to your router\u2019s control panel: open your browser and type the IP address of your router. Usually this is 192.168.1.1 or 192.168.0.1 or 192.168.1.254. Once you\u2019re prompted with a user and password login box, log in ( if you\u2019ve not changed them, there are good chances they would be: admin as both user and password). Navigate to the devices list,which can be called also status or manteinance, you should see your UDOO DUAL\/QUAD with his IP address. Here you are. Now that you know your IP address, you can easily access your UDOO DUAL\/QUAD","tags":"","url":"Basic_Setup\/Find_IP_Address.html"},{"title":"Web Control Panel","text":"The UDOO's Web Control Panel is a utility designed to: Easily configure your UDOO QUAD\/DUAL, from the Wireless Connection to the UDOO QUAD\/DUAL's hostname; Check its connection status; Learn how to develop basic projects; Test simple Arduino sketches on the fly; Expose the Documentation; How to connect to the UDOO Web Control Panel Make sure UDOO QUAD\/DUAL and your host computer are connected to the same network, so open a browser in your host computer and type the IP address of UDOO QUAD\/DUAL. You can use the UDOO Web Control Panel directly from the UDOO running UDOObuntu finding the link in the application panel in the section &quot;Preferences&quot; -&gt; &quot;UDOO Web Configuration&quot; Dashboard The Dashboard gives you a quick insight on the status of your UDOO QUAD\/DUAL: At the top, you'll find an overview of board's connectivity, indicating whether Ethernet, USB, Wlan and Bluetooth are connected, and their IP address; In the center, you can find board model and unique ID. On the right, there are axis and modulus values for the Accelerometer, Gyroscope and Magnetometer; The other tiles are the starting point on discovering UDOO QUAD\/DUAL's capabilities. Configuration This section helps you to configure your board and connect it to a wireless network: On &quot;Password and hostname&quot;, you can change your passwords and set a name for your board; On &quot;Network settings&quot;, you can connect to Wi-Fi networks; On &quot;Regional settings&quot; you can set the locale, timezone and regional settings; On &quot;Advanced settings&quot; you can change the main video output device (e.g. HDMI or LVDS), enable\/disable the Arduino core and change the TCP port where the Web Control Panel operates (so you can, for example, install a webserver on your board, like Apache or nginx),","tags":"","url":"Basic_Setup\/Web_Control_Panel.html"},{"title":"Remote Terminal (SSH)","text":"Requirements A first condition to establish a SSH connection with your UDOO QUAD\/DUAL is to have your host computer and the board connected to the same network. A second condition is to know the UDOO's IP Address. Finally you need to download and install an SSH Client for your system, like Putty Connection via SSH Once you have completed these steps, open your SSH client. For the sake of this example, we consider you're using PuTTY on Windows. Opening PuTTY a window will ask you to specify the destination you want to connect to. In the first blank space, named Host Name or IP address, type the IP Address of UDOO QUAD\/DUAL. Eventually, a Windows Firewall popup could appear the first time you do this. If this happens, allow PuTTY to bypass the firewall. When the connection succeeds, a black window will appear. That is the terminal. It will ask you to enter your login credential. Type udooer, then press &quot;Enter&quot;. A new line will appear: udooer@&lt;ip_address&gt;'s password: Type udooer (if you did not change your default password using the Web Control Panel yet, then press &quot;Enter&quot;. Do not worry if you don't see what you type in the terminal: it's an expedient to hide your password to eventual onlookers. At this point you can use your terminal: login as: udooer udooer@ip_address&gt;'s password: Welcome to Ubuntu 14.04.3 LTS (GNU\/Linux 3.14.56-udooqdl-xxxxxxxxxx armv7l) * Documentation: https:\/\/www.udoo.org\/docs\/ udooer@udoo:~$ Good job, mate: you are now connected to your UDOO QUAD\/DUAL via SSH.","tags":"","url":"Basic_Setup\/Remote_Terminal_(SSH).html"},{"title":"Remote Desktop (VNC)","text":"What you should do now is downloading a suitable VNC client, like VNC Viewer So, once downloaded just execute the program and install it. Then, open the program: a window will pop up. Assuming your host computer is connected to the same network of UDOO QUAD\/DUAL, type the UDOO's IP Address. in the VNC Server adddress, then press &quot;Connect&quot;. Then type your password (default password is udooer) and a new window will pop up in your desktop, that is the desktop of your UDOO QUAD\/DUAL! Done!","tags":"","url":"Basic_Setup\/Remote_Desktop_(VNC).html"},{"title":"UDOO Configuration Tool","text":"Warning! This tool is deprecated since UDOObuntu 2.0. It is present only in UDOObuntu 1.0\/1.1 versions. On UDOObuntu 2 use Web Control Panel instead. UDOO DUAL\/QUAD Configuration Tool is a utility created to assist UDOO DUAL\/QUAD basic and advanced Configuration. It comes preinstalled on UDOOBuntu Official UDOO DUAL\/QUAD Operating system. Tool Overview UDOO DUAL\/QUAD configuration Tool has several subsections: Change User Password Selecting this you'll be able to change default password for user ubuntu. It is what you'll achieve by manually doing: passwd Change Keyboard Layout This changes default keyboard layout. Change Timezone Settings This changes default timezone setting. This affects the Network Time Timezone Setting and sometimes can solve Networking Problems. Change Remote Desktop Password This changes the default Password of VNC Server. Default is ubuntu. Expand Filesystem to fill disk max capacity This expands filesystem of current Root Partition to fill the disk capacity. Set Default Boot Device This edits Uboot Environment allowing to select default Boot Device from MicroSD Card, SATA Drive or NFS. Set Default Video Output (LVDS\/HDMI) This allows to enable UDOO DUAL\/QUAD LVDS Panel, 7 or 15 inches. A reboot is required to enable them. Enable UDOO Camera Module This enables the Camera Module. A service is required to enable the loopback device. More informations about UDOO Camera Modules U-Boot Shows Current U-Boot environment. Change Ram mem layout This changes the quantity of memoery to allocate to the video card and to the framebuffer. Reset env This resets the environment Show env This shows the env","tags":"","url":"Basic_Setup\/UDOO_Configuration_Tool.html"},{"title":"Usb Direct Connection","text":"What is USB Direct Connection UDOO Dual\/Quad's Micro USB port can be used both to power up the board and to connect it to our computer. Connecting UDOO Dual\/Quad to your computer will result in: UDOO Dual\/Quad powering on, taking power from its USB Port A storage device will be available, containing UDOO Dual\/Quad'S Kernel and DTB files, together with an offline documentation and quick start guide UDOO Dual\/Quad will establish a network connection with your Computer, allowing to use it in [headless mode]!Getting_Started\/Use_as_a_headless_IoT_Device) In order to use UDOO Dual\/Quad'S USB Connection on Mac and Windows, you must install few drivers first as described below: Enable USB Direct Connection: Installing Drivers Linux doesn't need drivers to make USB connection work properly. For other OS follow the instuctions below. Installing Drivers on Mac OS X Install both of this drivers: Serial and Network Heads up! If you're using the Newest OSX EL CAPITAN please install this Network Driver insted. Reboot your MAC UDOO Dual\/Quad will be available at 192.168.7.2 Installing Drivers on Windows Connect UDOO Dual\/Quad via Micro USB Cable to PC, eventually you'll get the following message: Right click on Computer and select Manage. From System Tools, select Device Manager. It will show a list of devices currently connected with the development PC. In the list, RNDIS Kitl can be seen with an exclamation mark implying that driver has not been installed. Right click on it and select Update Driver Software... When prompted to choose how to search for device driver software, choose Browse my computer for driver software. Browse for driver software on your computer will come up. Select Let me pick from a list of device drivers on my computer. A window will come up asking to select the device type. Select Network adapters, as RNDIS emulates a network connection. In the Select Network Adapter window, select Microsoft Corporation from the Manufacturer list. Under the list of Network Adapter:, select Remote NDIS compatible device. The RNDIS Kitl device is now installed and ready for use. Use USB Direct Connection to control UDOO Dual\/Quad Upon successful connection, UDOO Dual\/Quad will be available at the address 192.168.7.2 You can establish a SSH Remote Terminal using the address 192.168.7.2 with credentials udooer\/udooer You can establish a VNC Remote Desktop Session using the address 192.168.7.2 and port 5900 (192.168.7.2:5900). The default password is udooer. You can configure UDOO Dual\/Quad via the Web Control Panel Troubleshooting If your UDOO Dual\/Quad doesn't appear as a mass storage or is not recognized by your MAC\\Pc, this may be due to insufficient power output from the USB port it is attached to. Therefore, try to: Change the USB port it is plugged into, to be on the safe side plug UDOO Dual\/Quad to USB 3.0 If you're on a Laptop, disable USB Power Saving mode Try to use a powered USB HUB","tags":"","url":"Basic_Setup\/Usb_Direct_Connection.html"},{"title":"UDOObuntu","text":"UDOObuntu is the official Linux-based operating system for the UDOO QUAD\/DUAL. Technical specifications UDOObuntu 2 is based on Ubuntu 14.04 LTS. It is provided in two flavours: without any GUI (ideal for headless installations) with a full LXDE desktop environment Both images can be downloaded from the image section of the website. Besides the Ubuntu 14.04 LTS specifications, UDOObuntu differs for the following elements: Linux kernel version 3.14.56 GPU accelerated Xorg 1.15 Arduino IDE 1.6.5 Chromium browser 48, with WebGL enabled gstreamer, which plays full HD videos via gplay QT 5.2.1 with X11 OpenGL ES2 GPU acceleration Web Control Panel Device Tree Editor, to control pinmuxing Updates The distribution uses the official Ubuntu repositories and the UDOO repository, so it is possible to update a running system in easy way via: sudo apt update sudo apt dist-upgrade Installation Instructions to download and flash the SD card image are available on this page. Default passwords The default user account is named udooer, and its password is udooer. The root password is ubuntu. Under the hood The UDOObuntu image available on UDOO website is a full image of an SD card with the following partition scheme: 1MB of reserved storage for the boot-loader (SPL, executable and environment variables) 32MB FAT partition, mounted in \/boot, which contains kernel, device trees and the documentation an EXT4 partition, mounted in \/, the root filesystem The root partition is automatically expanded at the first boot to the size of the SD card. Development UDOObuntu image is generated automatically from the build script mkudoobuntu. This tool builds recipes for different boards and image types (eg. with GUI or headless). The first step is to debootstrap a base Ubuntu armhf system. Then some configuration files are patched and UDOO specific packages are installed from the UDOO repository. Other old official UDOOBuntu distro. UDOObuntu 1.0\/1.1 was the official UDOO Distribution based on Ubuntu 12.04 LTS armHF with LXDE desktop environment. Kernel 3.0.35 - U-Boot 2013 Username: ubuntu Password: ubuntu Available at UDOO Downloads Page","tags":"","url":"Software_OS_Distro\/UDOObuntu.html"},{"title":"Android","text":"Android has been ported to UDOO QUAD\/DUAL. Technical specifications The stable Android version for UDOO QUAD\/DUAL is based on Android Marshmallow 6.0.1. The previous release, still available for download, is KitKat 4.4.2. SD card images can be downloaded from the image section of the website. Installation Instructions to download and flash the SD card image are available on this page. Development Instructions to download and compile the Android Source code for UDOO QUAD\/DUAL are available on the Compile Android From Source section.","tags":"","url":"Software_OS_Distro\/Android.html"},{"title":"Yocto","text":"Yocto is an unofficial distribution for UDOO boads. It is developed maintained by the community, almost entirely by Christian Ege who also started the porting of Yocto for UDOO boards. For problems you may encounter with this distribution your go-to place is the Yocto Subforum in UDOO Forum Also, Christian Ege is aso a user of the UDOO Forum, as well as admin of the Yocto Subforum. What is Yocto The Yocto Project is a Linux Foundation workgroup whose goal is to produce tools and processes that will enable the creation of Linux distributions for embedded software that are independent of the underlying architecture of the embedded software itself. The project was announced by the Linux Foundation in 2010. In March 2011, the project aligned itself with OpenEmbedded, an existing framework with similar goals, with the result being The OpenEmbedded-Core Project. The Yocto Project is an open source project whose focus is on improving the software development process for embedded Linux distributions. The Yocto Project provides interoperable tools, metadata, and processes that enable the rapid, repeatable development of Linux-based embedded systems. Project Scope The Yocto Project has the aim and objective of attempting to improve the lives of developers of customised Linux systems supporting the ARM, MIPS, PowerPC and x86\/x86 64 architectures. A key part of this is an open source build system, based around the OpenEmbedded architecture, that enables developers to create their own Linux distribution specific to their environment. This reference implementation of OpenEmbedded is called Poky. There are several other sub-projects under the project umbrella which include EGLIBC, pseudo, cross-prelink, Eclipse integration, ADT\/SDK, the matchbox suite of applications, and many others. One of the central goals of the project is interoperability among these tools. The project offers different sized targets from &quot;tiny&quot; to fully featured images which are configurable and customisable by the end user. The project encourages interaction with upstream projects and has contributed heavily to OpenEmbedded-Core and BitBake as well as to numerous upstream projects, including the Linux kernel.[citation needed] The resulting images are typically useful in systems where embedded Linux would be used, these being single-use focused systems or systems without the usual screens\/input devices associated with desktop Linux systems. As well as building Linux systems, there is also an ability to generate a toolchain for cross compilation and a software development kit (SDK) tailored to their own distribution, also referred to as the Application Developer Toolkit (ADT). The project tries to be software and vendor agnostic. Thus, for example, it is possible to select which package manager format to use (deb, rpm, or ipk). Within builds, there are options for various build-time sanity\/regression tests, and also the option to boot and test certain images under QEMU to validate the build. UDOO QUAD Download: udoo-image-qt5-udooqdl.wic.bz2 SHA256: be552caf5c97fcc4b7f677f96449b7c39e3c47ee4e4bda2614fb129a58c8f07d QT5 Toolchain poky-glibc-x86_64-udoo-image-qt5-cortexa9hf-neon-toolchain-2.1.1.sh SHA256: d0189f96e7d9e8cd7e871a4c96fc127262d0c7a161beadd61d9ef823eec7b505 Installation To install Yocto type into the terminal: umount \/dev\/sd&lt;disk&gt;?; bzcat \/tmp\/udoo-image-qt5-udooqdl.wic.bz2 | sudo dd of=\/dev\/&lt;disk&gt; bs=32M For more information visit this Yocto-related topic in the UDOO Forum. Here instead you can find the Open Embedded meta-layer for UDOO boards.","tags":"","url":"Software_OS_Distro\/Yocto.html"},{"title":"Other Unofficial Distributions","text":"Available Unofficial Distributions Apart from UDOObuntu and Android there are other Operating Systems available for UDOO Dual\/Quad, but they have not been developed \/ ported by the UDOO Team, and are not officially supported by the UDOO Team. Below you can find information about these Operating Systems. Please, note that the guides linked below may be outdated, and that we do not guarantee that they are not. If you find that the guides linked below are outdated and you got problems with these Operating Systems, search the website\/forum of the unofficial Operating System that you are using. If you want to edit the links below, make a pull request. General Purpose Debian Wheezy armHF Debian is an operating system composed of free software mostly carrying the GNU General Public License. The operating system is developed by an internet collaboration of volunteers aligned with The Debian Project. Username: debian Password: debian Available at UDOO Downloads Page Yocto The Yocto Project\u2122 is an open source collaboration project that provides templates, tools and methods to help you create custom Linux-based systems for embedded products regardless of the hardware architecture. Download Link for UDOO Quad only ArchLinux ArchLinux design approach of the development team focuses on elegance, code correctness, minimalism, and simplicity, and expects the user to be willing to make some effort to understand the system's operation.[7] A package manager written specifically for Arch Linux, pacman, is used to install, remove and update software packages. ArchLinux Install Guide for UDOO Multimedia XBMC XBMC is a free and open source media player developed by the XBMC Foundation, a non-profit technology consortium.XBMC is available for multiple operating systems and hardware platforms, with a software 10-foot user interface for use with televisions and remote controls. It allows users to play and view most videos, music, such as podcasts from the internet, and all common digital media files from local and network storage media. XBMC for UDOO by Stephan Rafin XBMC for UDOO by Isronga OpenElec OpenELEC (short for Open Embedded Linux Entertainment Center) is a Linux distribution designed for home theater PCs and based on the XBMC media player. OpenElec for UDOO DUAL\/QUAD has been announced but not yet released Volumio Volumio is a free and open source Audiophile Music Player. It is designed to play all your music, whether is an Hi-Res file or a Web Radio, with the highest quality. Control it with your favourite device, a smartphone, pc or tablet, and enjoy your music as you never did before. Download on Volumio.org Ubuntu Studio Ubuntu Studio is an officially recognized derivative of the Ubuntu Linux distribution, which is explicitly geared to general multimedia production. UDOO Quad Download Link UDOO Dual download Link Security Kali Linux Kali Linux is a Debian-derived Linux distribution designed for digital forensics and penetration testing. It is maintained and funded by Offensive Security Ltd. It was developed by Mati Aharoni and Devon Kearns of Offensive Security through the rewrite of BackTrack, their previous forensics Linux distribution. Kali for UDOO DUAL\/QUAD has been announced but not yet published. Robotics ROS ROS (Robot Operating System) provides libraries and tools to help software developers create robot applications. It provides hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more. ROS is licensed under an open source, BSD license. Install ROS on UDOO Network Attached Storage Open Media Vault OpenMediaVault is the next generation network attached storage (NAS) solution based on Debian Linux. It contains services like SSH, (S)FTP, SMB\/CIFS, DAAP media server, RSync, BitTorrent client and many more. With OpenMediaVault your can create your very own UDOO DUAL\/QUAD powered Home Server and NAS. Download link for UDOO QUAD only Forum Thread Domotics FreeDomotic Freedomotic is an open source, flexible, scalable and mashups oriented software that can interact with well known standard building automation protocols as well as with \u201cdo it yourself\u201d solutions. It treats the web, social networks and frontends just like any other sensor or actuator in your automation system. For example you can tweet your washing machine to start the washing cycle. It allows you to build smart spaces. Freedomotic can manage from small appartments to huge buildings, like museums, schools, corporate offices, malls and university campuses. Install FreeDomotics on UDOO","tags":"","url":"Software_OS_Distro\/Other_Unofficial_Distributions.html"},{"title":"GPIO Pinout","text":"Introduction In this chapter it will be described how UDOO DUAL\/QUAD manages the signals available on external pin header, and the way to control all the GPIOs. On UDOO DUAL\/QUAD, Freescale i.MX and Atmel SAM3X8E share most of the GPIOs available on external pin headers. Each pin of both processors can be set in INPUT or OUTPUT mode. In INPUT mode, each processor read the electrical level of the signal. In OUTPUT mode they can drive low or high the voltage level on each pin. So both processors can control all digital external pins. Usually, with Arduino Due, applications that manage external pins are developed to run on the SAM3x8E microcontroller. On UDOO DUAL\/QUAD it is possible to control external pins also using i.MX6 processor. UDOO DUAL\/QUAD GPIO Pinout Diagram Arduino DUE (SAM3x8E) GPI\/Os Management SAM3x8E microcontroller can manage GPIOs using classic Arduino programming language. To manage a GPIO in Arduino Environment it is necessary to set its direction (input or output) by calling the pinMode(pin, mode) function. pinMode(2, INPUT ); pinMode(2, OUTPUT ); If pin is set in input mode, its value can be read by using the function digitalRead(pin) providing pin number as parameter: e.g. int val = digitalRead(2); If pin is set in output mode, its value can be written by using the function digitalWrite(pin, value)providing the pin number and the value that must be written as parameters: digitalWrite(2, HIGH); digitalWrite(2, LOW); More information about Arduino programming Language can be found at Arduino Language Reference Page Go to the Arduino section to learn how to program the Arduino DUE embedded Linux (i.MX6) GPI\/Os Management i.MX6 can handle external pins in many different ways. In default configuration, they can be accessed from user level through the standard Kernel Linux interface. Some of them can be configured for specific functionalities provided by i.MX6 architecture, like SPI, I2C, I2S, audiomux, PWMs output, UARTs and so on. Go to the Device Tree Editor section to know how export these functionalities. By default (for safety reasons), all GPIOs are exported in input configuration from the Linux side, to let you use they from the Arduino DUE side. This means the board CPU can read the value of the voltage connected to the pins. The other possible configuration is output, which forces a pin to take a specific voltage. Heads up! When using the output configuration, be sure to avoid short-circuits! It is possible to switch a pin in input or output mode with the following commands: # set pin 25 to input echo in &gt; \/gpio\/pin25\/direction # set pin 25 to output echo out &gt; \/gpio\/pin25\/direction To verify the voltage direction, just read the same file: cat \/gpio\/pin25\/direction Write values To write a low or high value on a GPIO, you need to write 0 or 1 in the value file: # set GPIO 25 to low value - 0 volts echo 0 &gt; \/gpio\/pin25\/value # set GPIO 25 to high value - 3.3 volts echo 1 &gt; \/gpio\/pin25\/value In order to set the value, the GPIO must be in the out direction. Read values If the direction is set to in, it is possible to read the GPIO value reading the same file: cat \/gpio\/pin25\/value If the direction is set to out and you try to read the value, is not guaranteed that the value is coherent with the voltage found on the external pinout. To make your life even simplier, you can find a super handy printable label for your GPIOs (thanks ralphie79!). Advanced usage GPIO management is made simple by the udoo-gpio-export package, which comes pre-installed in UDOObuntu 2 Linux. This package takes care of exporting all GPIOs in input mode, and creates the symlinks from the \/sys\/class\/gpio entries to the \/gpio directory. If you want, you can directly use the \/sys\/class\/gpio entries. For example, to export a GPIO use: echo GPIO_NUMBER &gt; \/sys\/class\/gpio\/export Please note that GPIO_NUMBER is not the number written on the PCB. Instead, it is the number written in the round label close to the PCB number in the previous two images. For example, if you want to control the pin 24 (PCB name) you should read GPIO_25. GPIO_NUMBER can be calculated with the following relation: GPIO_NUMBER = ((BANK - 1) * 32 ) + ID For example, if you want to export the GPIO1_IO_25; # GPIO1_IO_25 means BANK=1 and ID=25 # GPIO_NUMBER = ((1 - 1) * 32 ) + 25 = 25 echo 25 &gt; \/sys\/class\/gpio\/export There\u2019s an handy table to help you sort out the correct GPIO numbers: PIN NUMBER GPIO NUMBER PATH 0 116 \/sys\/class\/gpio\/gpio116\/ 1 112 \/sys\/class\/gpio\/gpio112\/ 2 20 \/sys\/class\/gpio\/gpio20\/ 3 16 \/sys\/class\/gpio\/gpio16\/ 4 17 \/sys\/class\/gpio\/gpio17\/ 5 18 \/sys\/class\/gpio\/gpio18\/ 6 41 \/sys\/class\/gpio\/gpio41\/ 7 42 \/sys\/class\/gpio\/gpio42\/ 8 21 \/sys\/class\/gpio\/gpio21\/ 9 19 \/sys\/class\/gpio\/gpio19\/ 10 1 \/sys\/class\/gpio\/gpio1\/ 11 9 \/sys\/class\/gpio\/gpio9\/ 12 3 \/sys\/class\/gpio\/gpio3\/ 13 40 \/sys\/class\/gpio\/gpio40\/ 14 150 \/sys\/class\/gpio\/gpio150\/ 15 162 \/sys\/class\/gpio\/gpio162\/ 16 160 \/sys\/class\/gpio\/gpio160\/ 17 161 \/sys\/class\/gpio\/gpio161\/ 18 158 \/sys\/class\/gpio\/gpio158\/ 19 159 \/sys\/class\/gpio\/gpio159\/ 20 92 \/sys\/class\/gpio\/gpio92\/ 21 85 \/sys\/class\/gpio\/gpio85\/ 22 123 \/sys\/class\/gpio\/gpio123\/ 23 124 \/sys\/class\/gpio\/gpio124\/ 24 125 \/sys\/class\/gpio\/gpio125\/ 25 126 \/sys\/class\/gpio\/gpio126\/ 26 127 \/sys\/class\/gpio\/gpio127\/ 27 133 \/sys\/class\/gpio\/gpio133\/ 28 134 \/sys\/class\/gpio\/gpio134\/ 29 135 \/sys\/class\/gpio\/gpio135\/ 30 136 \/sys\/class\/gpio\/gpio136\/ 31 137 \/sys\/class\/gpio\/gpio137\/ 32 138 \/sys\/class\/gpio\/gpio138\/ 33 139 \/sys\/class\/gpio\/gpio139\/ 34 140 \/sys\/class\/gpio\/gpio140\/ 35 141 \/sys\/class\/gpio\/gpio141\/ 36 142 \/sys\/class\/gpio\/gpio142\/ 37 143 \/sys\/class\/gpio\/gpio143\/ 38 54 \/sys\/class\/gpio\/gpio54\/ 39 205 \/sys\/class\/gpio\/gpio205\/ 40 32 \/sys\/class\/gpio\/gpio32\/ 41 35 \/sys\/class\/gpio\/gpio35\/ 42 34 \/sys\/class\/gpio\/gpio34\/ 43 33 \/sys\/class\/gpio\/gpio33\/ 44 101 \/sys\/class\/gpio\/gpio101\/ 45 144 \/sys\/class\/gpio\/gpio144\/ 46 145 \/sys\/class\/gpio\/gpio145\/ 47 89 \/sys\/class\/gpio\/gpio89\/ 48 105 \/sys\/class\/gpio\/gpio105\/ 49 104 \/sys\/class\/gpio\/gpio104\/ 50 57 \/sys\/class\/gpio\/gpio57\/ 51 56 \/sys\/class\/gpio\/gpio56\/ 52 55 \/sys\/class\/gpio\/gpio55\/ 53 88 \/sys\/class\/gpio\/gpio88\/ GPIOs Warnings When changing i.MX6 GPIOs directions, it is necessary to pay special attention. New direction must be compatible with SAM3x8E pinout configuration and\/or with the load of the physical pin. A:GPIOs can be used to build a communication channel between the two processors. By setting one processor in INPUT mode, and the other in OUTPUT mode, a one-way channel will be created. Via software, it is possible to switch the direction on both processors, in order to create a half-duplex communication channel. B:Two processors simultaneously can read data from external devices. They can also write data to external devices or the other processor, but only one at a time can be set in output mode. C:The situations here illustrated must be avoided. In the first case, both processors set the shared pin in output mode. If they try to drive the shared line with different signal values, the resulting signal level will be unpredictable and it could result in damaging the processor driving the signal LOW. The same situation occurs when one external device tries to drive the shared line. WARNING! There isn\u2019t any automatic tool that can avoid dangerous situations. The programmer must develop Hardware and Software able to avoid the occurrence of dangerous situations. WARNING 2! UDOO DUAL\/QUAD I\/O pins are 3.3V only compliant. Providing shields with higher voltage, like 5V, could damage the board. Use only shields Arduino DUE compatible (3.3V). Extra functions available on UDOO DUAL\/QUAD pin headers UDOO DUAL\/QUAD can provide for extra features on external pin headers. To enable them it is necessary to declare the correct alternative pin function in the device tree of the kernel. UDOObuntu 2 provides a simple graphic tool to allow you to manage most of these functionalities: the Device Tree Editor. These functions are: UARTs: uart1, uart3, uart4, uart5 sd1 SPIs: spi1, spi2, spi5 i2c1 SPDIF timer capture timer compare WATCHDOG FUNCTIONALITIES: watchdog reset, watchdog out clock out PWMs: pwm1, pwm2, pwm3, pwm4 I2s Digital Audio On the vertical axis there are iMX6s functionalities. On the horizontal axis are shown the pins used to implements each functionality. Be careful that some pins are used for different functionalities and only one at a time can be active for each of them.","tags":"","url":"Hardware_Accessories\/GPIO_Pinout.html"},{"title":"IMX6 And Sam3X Communication","text":"UDOO DUAL\/QUAD features a powerful IMX6 ARM Cpu , which can execute all the piece of code you want, from simple word-processing to power-hungry 3d modeling tasks. Furthermore, it has a built-in Arduino Due compatible range of GPIOs and it's layout is perfectly compatible with all Arduino Due shields. In this tutorial we'll learn how to take advantage of both these platforms at the same time, how to make them interact and talk to each others. First, let's have a look on how UDOO DUAL\/QUAD's architecture has been designed. As you may know, on the board we find 2 processors: iMX6 - ARM CPU Dual\/Quad Core: This is the powertrain of UDOO DUAL\/QUAD's operating system. This CPU handles the O.S. environments, such as Android, Ubuntu, Debian etc. iMX6 handles also AudioVideo operations ( audio io, HDMI video, LVDS), USB ports, SATA connection, Network connection and so on. SAM3x - Arduino Due compatible processor: This is the core of UDOO DUAL\/QUAD's extended input and output support. You can use the Sam3x as a standalone Arduino board, connecting every sensor, motor , device etc. you want to it. You can also connect every Arduino Due compatible shield you may need for your project. UDOO DUAL\/QUAD features a serial channel that interconnects these 2 processors, and this is the way to go for advanced projects. The logical steps involved are really simple: How the two processors communicate? Below there are the possible connections between the two processors, explained and illustrated in an easy and intelligible way. Communication between i.MX6 and SAM3X through UART serial Between the two processors there\u2019s a direct UART serial connection which is always ON. Through this connection, you can, for example, upload your sketches to the SAM3X from the iMX6 running Linux within the Arduino IDE. In other words, through this serial connection, the two processor communicate directly between them. Like any other Arduino boards, serial data are also available at pin 0 and pin 1 OTG connection between i.MX6 and SAM3X This USB OTG connection is used, for example, for the ADK communication protocol between the iMX6 running Android and the SAM3X. In this way UDOO can act as an Android-powered device and its ADK accessory simultaneously. This connection can also be used to connect the iMX6 to the SAM3X while running Linux. The switch is controlled via software by the iMX6. Connection to the i.MX6 through UART serial from external computer Serial connection to the iMX6 from an external computer through USB serial. With this connection you have access, for example, to the iMX6 U-BOOT. The switch is controlled via software by the iMX6 or by a physical jumper (J18). With the J18 jumper plugged you can communicate with the iMX6 processor through the micro-USB connector CN6. Connection to the SAM3X from external computer Arduino compatible board embedded on UDOO can be also programmed from an external computer through the mini USB serial, like you are used to do with standard Arduino board. Like any other Arduino boards, serial data are also available at pin 0 and pin 1 (RX0\/TX0). The switch is controlled via software by the iMX6 or by a physical jumper (J18). With the J18 jumper NOT plugged you can communicate with the Arduino SAM3X processor through the micro-USB connector CN6. External OTG connection to i.MX6 The mini USB OTG, when switched to the iMX6 OTG BUS, can be used, for example, to communicate with UDOO as an Android device. This way you can use ADB protocol, install APKs, debugging purposes and all other uses of an OTG port on an Android device. While running Linux this is a standard USB OTG port. The switch is controlled via software by the iMX6. Communication Examples Both processors can listen and send data via the serial line, the only thing you need is check that they communicate at the same baudrate. So, you can tie up two different scripts or events manager, on both processors, and make them react the way you want. To have full examples of communication in different programming languages (Java, C, PHP, Python) go to the Serial libraries examples Let's view some bash scenarios: Unidirectional Communication from Linux to Arduino The Arduino part will turn on a LED when a script is launched on the Linux OS running on the iMX6 part In this scenario, the first step is to properly set the serial port on Linux: stty -F \/dev\/ttymxc3 cs8 115200 ignbrk -brkint -icrnl -imaxbel -opost -onlcr -isig -icanon -iexten -echo -echoe -echok -echoctl -echoke noflsh -ixon -crtscts As you may imagine, \/dev\/ttymxc3 is the serial port and 115200 is the baudrate we selected. Then, we just set up our script. This will write the desired data on to the serial port. Now, we step up into the Sam3x part and upload our sketch. The sketch will listen the serial port, at the previously set baudrate, waiting for the information sent by the iMX6. Of course our sketch will have a trigger command set accordingly to the script we set on the iMX6. Let's see a brief example: I have a python script, that writes &quot;1&quot; on \/dev\/ttymxc3 when a keyboard button is pressed. I properly set the serial port, at 115200 with the script: stty -F \/dev\/ttymxc3 cs8 115200 ignbrk -brkint -icrnl -imaxbel -opost -onlcr -isig -icanon -iexten -echo -echoe -echok -echoctl -echoke noflsh -ixon -crtscts I upload a sketch that listen on the serial port, and when it receives &quot;1&quot;, it will turn a LED to HIGH state. I launch my python script. Which starts waiting for a key to be pressed. Sam3x is listening. When I press a key, a series of events will take place, ultimately resulting in my Led turning on: KEY -&gt; Pyhton script writes 1 on serial -&gt; SAM3x gets triggered and turns on the LED This is of course a very simple scenario, almost the simples you can get. But the logical pathway we examined is pretty the same when you climb up on complexity. Unidirectional Communication from Arduino to Linux Now, let's examine the opposite scenario: A Linux application will output some data gathered from sensors connected to the Sam3x via an Arduino sensor shield Again, what we need to do is set our serial port accordingly to the baudrate set by the sketch. The SAM3x will collect some data from it's sensors, and send them, appropriately coded, via serial. On the Linux Side, we can set up a local server that listens for serial data and stores it on a local database, for example a mysql db. Or that outputs a video feedback if a certain data comes from the sensor reading. Again, let's see a brief example: I have a sensor that reads environmental data, such as temperature and atmospheric pressure. I upload my Arduino sketch, that will send both of these readings via serial every 1 second. I set serial port baud rate at 115200 To match SAM3x serial speed, II properly set the serial port at 115200 on the iMX6 with the script: stty -F \/dev\/ttymxc3 cs8 115200 ignbrk -brkint -icrnl -imaxbel -opost -onlcr -isig -icanon -iexten -echo -echoe -echok -echoctl -echoke noflsh -ixon -crtscts We set up a server that both listens to the data sent from Serial, and stores them on a mysql database. Furthermore, we can set up a script that pops-up a video alert if certain values are read from the sensors. Again, this basic principle can be expanded to create more complex situations. This is up to you and your creativity. The ultimate scenario is however the bidirectional communication, that occurs when both systems reads and listens reciprocally. Bidirectional communication As a mere example, we can merge the above scenarios into one integrated application: I have a sensor that reads environmental data, such as temperature and atmospheric pressure. I upload my Arduino sketch, that will send both of these readings via serial every 1 second. I set serial port baud rate at 115200 To match SAM3x serial speed, we properly set the serial port at 115200 on the iMX6 with the script: stty -F \/dev\/ttymxc3 cs8 115200 ignbrk -brkint -icrnl -imaxbel -opost -onlcr -isig -icanon -iexten -echo -echoe -echok -echoctl -echoke noflsh -ixon -crtscts We set up a server that both listens to the data sent from Serial, and stores them on a mysql database. Then, I can choose to output the mean averages of temperature and atmospheric pressure with an LED array connected to the Arduino part. I configure the server to write the data to be displayed with the LED array on \/dev\/ttymxc3, with the same baudrate I set before I integrate the Arduino sketch previously loaded in order to add serial listening and writing on the LED array As you can see, this is a step forward from what we've previously seen as the system is using the serial connection as a bidirectional communication pathway, and the Linux system and Arduino sketch are also both receiving and sending data at the same time. Again, you can add even more complexity layers, UDOO DUAL\/QUAD can handle them. Last but not least, UDOO DUAL\/QUAD is also capable of driving its GPIO pins as other embedded boards, like Raspberry Pi, the direct way. This is the simplest way of controlling them, but bear in mind that this procedure enables you to control them only via the Linux or Android iMX6 system. This offers another interesting scenario: Controlling GPIO via iMX6 while they are also drived by SAM3x Arduino compatible controller WARNING: Setting up the same pin on different states in the same time, or controlling it at the same time with both iMX6 and SAM3x will result in damaging your board. Please make sure a pin\/GPIO can have only one state at the same time, and it's controlled only by one processor at the time This allows to conveniently control the GPIOs for iMX6 related tasks, while letting Arduino do its job with a custom sketch. Let's see an example: I have an audio player running on Linux, and want to output artist and song name on a Oled display drived via i2c protocol (iMX6 direct GPIO handling) At the same time I can connect a rotary controller to SAM3x to control the output volume via an analog knob. I upload a sketch that reads the volume knob position and writes it to serial (Arduino to iMX6 via serial) I start a script on iMX6 that reads the volume knob position and tunes the volume mixer accordingly.","tags":"","url":"Hardware_Accessories\/IMX6_And_Sam3X_Communication.html"},{"title":"UDOO LVDS Panels","text":"By default, UDOO QUAD\/DUAL displays the graphical user interface on the HDMI port. LVDS screens can be connected to the CN13 port. Before the screen can be used, it must be enabled as it follows. You cannot use the HDMI and the LVDS7 or LVDS15 video outputs simultaneously. Warning! Make sure to plug the display cable when the board is turned off. Make sure you are powering your UDOO QUAD\/DUAL with a 12V power supply when using LVDS screens. 7-inches LVDS panel The KIT LCD 7&quot; - Touch for QUAD\/DUAL is compatible with UDOO QUAD\/DUAL. If you previously bought one for the UDOO NEO, you just need to buy a new cable and keep the same screen. If you are searching for technical details check the UDOO 7&quot; Touch Panel Display Kit Datasheet 15-inches LVDS panel The KIT LCD 15,6&quot; for QUAD\/DUAL and the KIT LCD 15,6&quot; Touch for QUAD\/DUAL are compatible with UDOO QUAD\/DUAL. If you are searching for technical details check the UDOO 15&quot; Touch Panel Display Kit Datasheet Linux (UDOObuntu 2) Android 6.x Android 4.x Switch video output from HDMI to LVDS After you connect your LVDS screen to the CN13 connector, you must tell UDOO QUAD\/DUAL to use the LVDS panel to draw the GUI. This can be done in several ways: Option 1: you have an HDMI monitor and mouse\/keyboard If you have an HDMI screen connected to UDOO QUAD\/DUAL, open a terminal with the link on the desktop. Then you can switch the main video output from HDMI to LVDS7 or LVDS15 by typing: sudo udooscreenctl set lvds7 sudo udooscreenctl set lvds15 (default password, if you did not change it, is udooer) You can revert this change by typing: sudo udooscreenctl set hdmi If you want more info about the udooscreenctl command visit the Set Video Output. If you prefer a graphical simple way to change the default video output, it is provided by the UDOO Web Control Panel in the &quot;Configuration&quot;-&gt;&quot;Advanced setting&quot; section. Option 2: you can connect via VNC or SSH If you can connect to your board via VNC or via SSH (using the USB, WiFi or Ethernet connection) , you can follow the steps explained in the previous section. Option 3: you have neither HDMI nor network If you cannot connect to your board via the network (VNC or SSH) and you have no HDMI screen, you can enable the LVDS display port editing a file in the UDOO QUAD\/DUAL SD card. Put the flashed SD card in your computer. A small FAT partition labelled boot will appear: Open the file named uEnv.txt contained in the partition. Heads up! The file must be saved with Unix-like line endings: Windows users can use the free Notepad++ text editor to safely edit the file. Mac OS X users can use the free TextWrangler text editor to safely edit the file. Linux users can use their favourite text editor (gedit, vim, nano) without concerns. Open the file and, you will need to add this line (if it isn't present): video_output= After the = character you need to put the word hdmi or lvds7 or lvds15 for the screen you need: video_output=hdmi video_output=lvds7 video_output=lvds15 e.g. : Save the file, eject the boot partition and restart the board. Touch Calibration if you have any problem with touch calibration try to modify the text files: \/etc\/X11\/xorg.conf.d\/90-st1232touchscreen.conf (for the 7&quot; Touch Display) \/etc\/X11\/xorg.conf.d\/91-3m_touchscreen.conf (for the 15,6&quot; Touch Display) These are the default values for the 7&quot; Touch Display: Section &quot;InputClass&quot; Identifier &quot;Touchscreen&quot; MatchProduct &quot;st1232-touchscreen&quot; Driver &quot;evdev&quot; Option &quot;Calibration&quot; &quot;3 794 476 0&quot; EndSection These for the 15,6\" Touch Display: Section &quot;InputClass&quot; Identifier &quot;calibration&quot; MatchProduct &quot;3M 3M USB Touchscreen - EX II&quot; Option &quot;Calibration&quot; &quot;1853 14628 2589 14106&quot; Option &quot;SwapAxes&quot; &quot;1&quot; EndSection If the calibration is not good enough you can connect a mouse to UDOO DUAL\/QUAD and launch the &quot;Calibrate Touchscreen&quot; application from the bottom bar: Application Menu -&gt; System Tools -&gt; Calibrate Touchscreen or running in a terminal the command: xinput_calibrator and follow the video instruction to change your calibration. The official UDOO's Android 6.x version allow you to configure the Video Output directly from the Settings App. Visit the UDOO Android Settings section for more info. Manual Video Output Configuration To use your LVDS with UDOO DUAL\/QUAD you have to follow these simple instructions. First connect an external pc to the debug serial of UDOO DUAL\/QUAD. Once done connect the serial USB Cable to UDOO DUAL\/QUAD and turn it on by plugging the Power Supply. From your computer, hit a key before normal boot starts up and type the right parameters for your Operating system and LVDS panel. The default Variable, which outputs to HDMI is: video=mxcfb0:dev=hdmi,1920x1080M@60,if=RGB24,bpp=32 Exact UBOOT Parameters 15&quot; Android setenv bootargs console=ttymxc1,115200 init=\/init video=mxcfb0:dev=ldb,1366x768M@60,if=RGB24,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=28M vmalloc=400M androidboot.console=ttymxc1 androidboot.hardware=freescale mem=1024M 7&quot; Android setenv bootargs console=ttymxc1,115200 init=\/init video=mxcfb0:dev=ldb,LDB-WVGA,if=RGB666,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=28M vmalloc=400M androidboot.console=ttymxc1 androidboot.hardware=freescale mem=1024M HDMI Android setenv bootargs console=ttymxc1,115200 init=\/init video=mxcfb0:dev=hdmi,1920x1080M@60,if=RGB24,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=28M vmalloc=400M androidboot.console=ttymxc1 androidboot.hardware=freescale mem=1024M At the next boot the video source will again be the default one unless you save the configuration you just inserted with the command: saveenv In Android you can also boot UDOO DUAL\/QUAD from both HDMI and LVDS panel at the same time inserting these variables in a different frame buffer: e.g. boot on lvds 15? and hdmi. setenv bootargs console=ttymxc1,115200 init=\/init video=mxcfb0:dev=ldb,LDB-WVGA,if=RGB666,bpp=32 video=mxcfb1:dev=hdmi,1920x1080M@60,if=RGB24,bpp=32 video=mxcfb2:off fbmem=28M vmalloc=400M androidboot.console=ttymxc1 androidboot.hardware=freescale mem=1024M The general Purpose parameters for each video output are: 15&quot; video=mxcfb0:dev=ldb,1366x768M@60,if=RGB24,bpp=32 7&quot; video=mxcfb0:dev=ldb,LDB-WVGA,if=RGB666,bpp=32 hdmi video=mxcfb0:dev=hdmi,1920x1080M@60,if=RGB24,bpp=32 (default environment variable)","tags":"","url":"Hardware_Accessories\/UDOO_LVDS_Panels.html"},{"title":"UDOO Camera Module","text":"Specifications Auto focus control (AFC) with embedded AF VCM driver Sensitivity: 600mV\/lux-sec Video capture in Full Field of View (FOV): double sensitivity,improved signal-to.noise ratio (SNR) Post-binning re-sampling filter for sharper, crisper contours and colours Internal anti-shaking engine Image transfer rate VGA (320x480) @120fps VGA (640x480) @90fps 720p @60fps 1280x960 @45fps 1080p @30fps QSXGA (2592x1944) @15fps UDOO Camera Module Datasheet Usage Connection UDOO Camera module is designed to be connected via CSI interface to UDOO Camera Connector. Connection is made via a FLAT-213-16PIN cable. Make sure the blue part of the ribbon cable looks backwords respect to the camera side. Lift the brown strip of the UDOO's camera connector and insert the ribbon cable into the connector making sure it goes as deep as it can, then pull down the brown strip of the connector to hold the cable. Make sure again that the blue part of the ribbon cable is looking on the outer side of UDOO. To a clearer explanation of how to connect the UDOO Camera Module you can check the initial part of this video. Video Explanation of UDOO Camera Module Connection Important: Never Connect UDOO Camera Module when UDOO DUAL\/QUAD is on! This could potentially damage the board and the camera. Camera With Android No additional operations needed. Just connect the Camera Module and boot Android. The camera will be automatically recognized by the system. Use the Camera App to use the Camera or develop your own APP using the standard Android Camera API. Using with Gstreamer on Linux UDOO Camera can be accessed in Hardware mode using Gstreamer 1.0 Pipelines Specifically with Freescale-provided elements and pugins. Starting from UDOObuntu 2 (Ubuntu 14.04 - Kernel 3.14.x) you can use gstreamer 1.0 and gstreamer-imx plugin to use the camera. To get camera's stream in Fullscreen mode, you can use: gst-launch-1.0 imxv4l2videosrc ! imxipuvideosink To retrive camera's stream in windowed mode, use gst-launch-1.0 imxv4l2videosrc ! imxeglvivsink To save a picture from camera's stream use gst-launch-1.0 imxv4l2videosrc num-buffers=1 ! jpegenc ! filesink location=capture1.jpeg If you wish to retrieve more information on imxv4l2videosrc or other plugin, you can use gst-inspect-1.0 imxv4l2videosrc There are lot of useful option you can use from the imx plugins. For example, you can find information of how to change the resolution of the camera stream using the 'imx-capture-mode' option of the imxv4l2videosrc plugin. imx-capture-mode : Capture mode of camera, varies with each v4l2 driver, for example ov5460: ov5640_mode_VGA_640_480 = 0, ov5640_mode_QVGA_320_240 = 1, ov5640_mode_NTSC_720_480 = 2, ov5640_mode_PAL_720_576 = 3, ov5640_mode_720P_1280_720 = 4, ov5640_mode_1080P_1920_1080 = 5 flags: readable, writable Another example is the useful option 'use-vsync' of the imxipuvideosink plugin. You can use this option to avoid video tearing. E.g. To get camera's stream in Fullscreen mode in 1080p resolution avoiding video tearing, you can use: gst-launch-1.0 imxv4l2videosrc imx-capture-mode=5 ! imxipuvideosink use-vsync=true More thorough information on gstreamer pipelines can be found at this links: Gstreamer-imx Gateworks video Streaming with Gstreamer on UDOObuntu To create a stream using HW encoding you can use Gstreamer. For example to create a low latency stream server of the UDOO Camera Module from UDOObuntu you can use this command: gst-launch-1.0 imxv4l2videosrc ! imxvpuenc ! tcpserversink host=&lt;UDOO_ip&gt; port=9000 On a Linux client you can play the stream using MPlayer media player with this command: nc &lt;UDOO_ip&gt; 9000 | mplayer -nocache -framedrop -benchmark - If you get an error related to LIRC, add the following line to the file ~\/.mplayer\/conf of the client: lirc=no You can find an example of an RTSP stream here: Gateworks Streaming (RTSP streaming example) Using with Loopback Device Warning! This following Loopback Device section is deprecated since UDOObuntu 2.0. It is present only in UDOObuntu 1.0\/1.1 versions. To use UDOO Camera Module as an ordinary webcam a loopback device is necessary. We can create such device routing the video stream from the camera to a virtual \/dev\/video device via v4l2loopback In order to achieve what above we need to have v4l2loopback kernel module enabled (default on UDOO DUAL\/QUAD Kernel) gstreamer binaries installed (gst-launch) To create a loopback device on \/dev\/video7 called UDOO Camera Module we can then execute sudo modprobe v4l2loopback video_nr=7 card_label=&quot;UDOO Camera Module&quot; sudo gst-launch-0.10 mfw_v4lsrc ! ffmpegcolorspace ! v4l2sink device=\/dev\/video7 The first command loads v4l2loopback module and creates the video loopback device while sudo gst-launch-0.10 puts the hardware streams in it. Now we can access the UDOO Camera module as an ordinary webcam","tags":"","url":"Hardware_Accessories\/UDOO_Camera_Module.html"},{"title":"Boot from SATA","text":"This guide will show you how to boot your UDOO DUAL\/QUAD from an attached SATA drive with the help of a small SD card. NOTE: It is not possible to boot without an SD card, it is hoped that this feature will be added in the future. Prerequisites A SATA drive A SD card A micro USB cable such as one for charging a smart phone UDOObuntu 2.0 UDOObuntu 1.0\/1.1 UDOObuntu 2.0 Flash the boot SD card You need an SD card with the bootloader in order to boot from SATA. Download this small (1MB) boot image and, after unzipping it, flash it to the SD: dd if=qdl-sata.img of=\/dev\/mmcblk0 bs=1M Flash the SATA drive Download the latest UDOObuntu from the official site. Decompress the image and flash it to the SATA drive: # in this example, the SATA drive device is \/dev\/SATA dd if=UDOObuntu_qdl_v2.0.img of=\/dev\/SATA bs=1M Remember to patch the \/etc\/fstab inside the SATA disk: mount \/dev\/SATA2 \/mnt\/sata echo &quot;\/dev\/sda2 \/ ext4 defaults,noatime 0 0 \/dev\/sda1 \/boot vfat defaults,noatime 0 0&quot; &gt; \/mnt\/sata\/etc\/fstab Please note: \/dev\/SATA2 is the second partition, available after flashing UDOObuntu; \/dev\/sda1,2 inside fstab must not be changed, these are the devices for the SATA partitions as seen by UDOO, not by your computer. UDOObuntu 1.0\/1.1 Preparing the drive You may partition and format the drive however you want, the current builds of uboot support up to ext3 I believe, newer builds may support ext4. I will be using a drive of a single ext3 partition as an example. There are several methods of preparing the SATA drive, some are listed below. NOTE: you only need to do ONE of the following methods. Using an existing Linux system Extracting a FS tarball Using dd to flash an image Using win32diskimager from windows Using an existing Linux system Connect your SD and SATA drive to a linux system. I'm using a USB SATA adapter and mounted it and the sd at \/sd and \/usb just for clarity, but this is upto you. Adjust commands appropriately. # cp -rvp \/sd\/* \/usb\/ This will copy your SD filesystem to the SATA disk. Unmount both. Once that is complete, connect the SATA disk to the UDOO DUAL\/QUAD and reinsert the SD card. Extracting a FS tarball You may use the filesystem tarball from the binaries tab on udoo.org or use your own. Place this tarball on the SATA disk. You can transfer this over the network or wget the file straight onto it. Run the following commands (Assuming \/dev\/sda1 is mounted at \/mnt) # cd \/mnt # tar xvzf tarball_you_just_grabbed.tar Using dd to flash an image You can also flash the filesystem using DD. You will need a filessytem img such as the ones provided by UDOO DUAL\/QUAD. Make sure your SATA disk is NOT mounted. Flash by doing the following: # dd if=path\/to\/fs.img of=\/dev\/sdb Using win32diskimager from windows You can flash any image from windows with win32diskimager. You can get it from its SourceForge page http:\/\/sourceforge.net\/projects\/win32diskimager\/ ##Prepare U-Boot The easiest way to start the OS from SATA is using the Configuration Tool preinstalled on UDOObuntu. Run UDOObuntu from MicroSD. Make sure the SATA Hard Drive you prepared above is plugged to your UDOO DUAL\/QUAD. Open the Configuration Tool, select &quot;Set Default Boot Device&quot; and choose SATA, then follow the simple instructions to select the right drive and partition. If you don't have the UDOO DUAL\/QUAD Configuration Tool available you can set your custom U-Boot following the instructions below: This is a temporary guide, since a new version of u-boot with a reorganization of the environment variables is scheduled and will be released asap. You will need to connect the UDOO DUAL\/QUAD to a PC with a micro USB cable. Make sure to use the micro USB port closest to the corner(CN6). Then open a serial terminal to the new COM port on your PC with a baud of 115200 Reset the UDOO DUAL\/QUAD and press any key over serial when prompted to cancel the autoboot. If you miss the prompt, you can press reset on the UDOO DUAL\/QUAD or run the reboot command to reboot. With the SATA hard drive connected run the command: sata part It will display some informations: Partition Map for SATA device 0 -- Partition Type: DOS Part Start Sector Num Sectors UUID Type 1 16065 14185395 000c356e-01 83 Take note of the device n\u00b0 and Part n\u00b0 information. Now run the following commands: setenv bootcmd &quot;if run loadbootscript; then run bootscript; else run sataboot; run mmcboot; run netboot; fi;&quot; setenv mmcloaduimage ext2load mmc ${mmcdev}:${mmcpart} ${loadaddr} ${uimage} setenv mmcboot &quot;if mmc rescan; then echo Booting from mmc ...; run mmcloaduimage; run mmcargs; bootm; else mmc boot failed; fi;&quot; setenv satadev &lt;device n\u00b0 previously noted e.g. setenv satadev 0&gt; setenv satapart &lt;part n\u00b0 previously noted e.g. setenv satapart 1&gt; setenv sataroot \/dev\/sda${satapart} rootwait rw setenv sataargs setenv bootargs console=${console},${baudrate} root=${sataroot} ${hdmi_patch} fbmem=24M video=mxcfb0:dev=hdmi,1920x1080M@60,bpp=32 setenv sataloaduimage ext2load sata ${satadev}:${satapart} ${loadaddr} ${uimage} setenv sataboot &quot;if sata init; then echo Booting from sata ...; run sataloaduimage; run sataargs; bootm; else sata boot failed; fi;&quot; saveenv In this way, if you have a connected SATA hard drive, the boot will be from SATA otherwise it will occur from SD card. Now run the following to continue booting: boot Done! You should now be booting into the system on the SATA drive. If all goes well you can safely remove almost everything on the SD card. NOTE! If you used the udooupdate script to update the uboot version and kernel, you'll probably need to do this on both the SD card that triggers the boot as well as the SATA drive. Use the instructions here to change which filesystem is the root, download and run the update from each. DO the SATA drive FIRST!!!! If you only do the SATA drive, you probably will not be able to reboot into the SATA drive until you also update the SD card to match.","tags":"","url":"Hardware_Accessories\/Boot_from_SATA.html"},{"title":"SPI","text":"From Wikipedia: The Serial Peripheral Interface bus (SPI) is a synchronous serial communication interface specification used for short distance communication, primarily in embedded systems. The interface was developed by Motorola and has become a de facto standard. Typical applications include sensors, Secure Digital cards, and liquid crystal displays. SPI devices communicate in full duplex mode using a master-slave architecture with a single master. The master device originates the frame for reading and writing. Multiple slave devices are supported through selection with individual slave select (SS) lines. ECSPI From the NXP iMX 6 Quad\/Dual Reference Manual: The Enhanced Configurable Serial Peripheral Interface (ECSPI) is a full-duplex, synchronous, four-wire serial communication block. The ECSPI contains a 64 x 32 receive buffer (RXFIFO) and a 64 x 32 transmit buffer (TXFIFO). With data FIFOs, the ECSPI allows rapid data communication with fewer software interrupts. The figure below shows a block diagram of the ECSPI. Key features of the ECSPI include: Full-duplex synchronous serial interface Master\/Slave configurable Four Chip Select (SS) signals to support multiple peripherals Transfer continuation function allows unlimited length data transfers 32-bit wide by 64-entry FIFO for both transmit and receive data Polarity and phase of the Chip Select (SS) and SPI Clock (SCLK) are configurable Direct Memory Access (DMA) support Max operation frequency up to the reference clock frequency. The ECSPI supports the modes described in the indicated sections: Master Mode Slave Mode Low Power Modes For more detailed information look at the Chapter 21 of the iMX 6 Quad\/Dual Reference Manual UDOO QUAD\/DUAL SPI channels UDOO QUAD\/DUAL exposes 2 ECSPI channels: MISO MOSI CLOCK SS0 SS1 SS2 SS3 ECSPI_1 45 37 36 46 31 53 47 ECSPI_2 50 51 52 34 31 53 47 ECSPI_5 3 5 2 4 9 8 - By default the SPI buses are not enabled and their pins are configured as GPIO. In order to enable ECSPI, follow this guide. ECSPI 1 ECSPI 1 is a full SPI, including Select Signals (SS0, SS1, SS2). ECSPI 2 ECSPI 2 is a full SPI, including Select Signals (SS0, SS1, SS2). ECSPI 5 ECSPI 5 has only six signals exposed (MISO, MOSI, SCLK, SS0, SS1, SS2), and many of them are shared with SD1. Use SPI is used by many sensor chips, flash memories, displays and other perifericals following a master-slave with a single master. UDOO QUAD\/DUAL supports master mode only on its Enhanced Configurable SPI (ECSPI). The protocol consist of four main signals: MISO: Master Input Slave Output MOSI: Master Output Slave Input SCLK: Serial Clock SS: Slave Select If you want to simply use it from a user application, just enable the ecspi{X} peripherical from the Device Tree Editor and use the spidev module to interact with it. In order to reduce conficts with other devices, SPI buses enabled from the Device Tree Editor have only SS0 signal as chip select. Example From Linux-Sunxi website: char *buffer; char buf[10]; file=spi_init(&quot;\/dev\/spidev0.0&quot;); \/\/dev buf[0] = 0x41; buf[1] = 0xFF; spi_write(0xE6,0x0E,2,buf,file); \/\/this will write value 0x41FF to the address 0xE60E buffer=(char *)spi_read(0xE6,0x0E,4,file); \/\/reading the address 0xE60E close(file);","tags":"","url":"Hardware_Accessories\/SPI.html"},{"title":"PWM","text":"Pulse Width Modulation is a modulation technique where a digital pin alternates high and low. It is possible to configure the period (how frequent should the output oscillate) and the duty cycly (how much should the output stay high). PWM signals can be used to: control LEDs brightness control colors on RGB LEDs control motors, like servos etc. Step 1: enable PWM outputs Enable the PWM features on the external pinout using the device tree editor. Step 2: configure the outputs Before configuring a PWM output, it is necessary to export it: echo 0 &gt; \/sys\/class\/pwm\/pwmchip0\/export Then set period and duty cycle. For example, to generate a 1kHz signal with 30% of duty cycle, use: echo 1000000 &gt; \/sys\/class\/pwm\/pwmchip0\/pwm0\/period echo 300000 &gt; \/sys\/class\/pwm\/pwmchip0\/pwm0\/duty_cycle Then enable the PWM output: echo 1 &gt; \/sys\/class\/pwm\/pwmchip0\/pwm0\/enable Possible values to be used period - The total period of the PWM signal (read\/write). Value is in nanoseconds and is the sum of the active and inactive time of the PWM. duty_cycle - The active time of the PWM signal (read\/write). Value is in nanoseconds and must be less than the period. enable - Enable\/disable the PWM signal (read\/write); 0 means disabled PWM settings generator Select the desired frequency and duty cycle: PWM frequency Duty cicle Generated code echo 123456789 &gt; \/sys\/class\/pwm\/pwmchip0\/pwm0\/period echo 987654321 &gt; \/sys\/class\/pwm\/pwmchip0\/pwm0\/duty_cycle","tags":"","url":"Hardware_Accessories\/PWM.html"},{"title":"Watchdog","text":"A watchdog timer (also called WDT, sometimes called a computer operating properly, a COP timer, or simply a watchdog) is an electronic timer used to detect and recover from computer malfunctions. During normal operations, the computer regularly restarts the watchdog timer to prevent it from elapsing, or &quot;timing out&quot;. If, due to a hardware fault or program error, the computer fails to restart the watchdog, the timer will elapse and generate a timeout signal. The timeout signal is used to initiate corrective action or actions. The corrective actions typically include placing the computer system in a safe state and restoring normal system operation. You can use the watchdog to provide hardware stability control to your projects. To enable Watchdog function you need to export two GPIOs. You should run these commands as root user: sudo su Enter root password. Export the two GPIOs. echo 132 &gt; \/sys\/class\/gpio\/export &amp;&amp; echo 83 &gt; \/sys\/class\/gpio\/export gpio132 ---&gt; WDT_EN ---&gt; Enable\/disable Watchdog (LOW =&gt; ENABLE) gpio83 ---&gt; WDT_TR ---&gt; Trigger signal Set the WDT_EN signal as output with high value. This signal enable Watchdog when it's LOW. echo out &gt; \/sys\/class\/gpio\/gpio132\/direction &amp;&amp; echo 1 &gt; \/sys\/class\/gpio\/gpio132\/value Now you should create and launch some task that generates a trigger sequence command. This C program generates an impulse sequence at 5Hz (each pulse is 0.2 second long). Open a terminal, create and open a file named, for example, wdoggy.c: nano wdoggy.c Copy this content inside the file: #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; int main(void){ printf(&quot;UDOO Watchdog trigger example running ...&quot;); system( &quot;echo out &gt; \/sys\/class\/gpio\/gpio83\/direction&quot; ); for(;;) { system( &quot;echo 0 &gt; \/sys\/class\/gpio\/gpio83\/value&quot; ); usleep(100000); system( &quot;echo 1 &gt; \/sys\/class\/gpio\/gpio83\/value&quot; ); usleep(100000); } } Save the file, and compile it: gcc wdoggy.c -o wdoggy Then run it: .\/wdoggy If you try to stop the process, after one second the board reboots automatically. So if you need a watchdog function in your application you need to enable the Watchdog and provide a service that pings the WDT_TR more then once per second.","tags":"","url":"Hardware_Accessories\/Watchdog.html"},{"title":"Resources","text":"Schematics Here you can find the schematics files of the UDOO X86: Schematics Top Bottom Bill of Material (BOM) Here you can find the Bill of Materials(BOM) file of the UDOO X86: Bill of Material (BOM) Mechanical Specs - 3D Design Files Here you can find the mechanical specs files of the UDOO X86: UDOO QUAD 3D-2D Design File UDOO DUAL 3D-2D Design File UDOO QUAD-DUAL Gerber File Pinout Diagrams UDOO QUAD-DUAL Pinout Alternate Table UDOO QUAD-DUAL Pinout Diagram","tags":"","url":"Hardware_Accessories\/Resources.html"},{"title":"WiFi","text":"Ralink\/Mediatek RT5370 UDOO QUAD\/DUAL uses the Ralink\/Mediatek RT5370 to provide the Wi-Fi connectivity. Ralink\/MediaTek RT5370 is a system on a chip (SOC) with a USB 2.0 interface for 802.11n Wi-Fi at data rates up to 150Mbit\/s. RT5370 features integrated 802.11n baseband and MAC (media access control), power amplifier and low-noise amplifier, along with both transmit-receive and antenna diversity switches. Together with an optimised RF architecture and baseband algorithms, RT5370 gives superb performance and reliable throughput with low power consumption. Model: GWF-3M08 Ralink RT5370(DC\/DC) MAC\/BBP General Features: 802.11n (2.4GHz) 1T1R with 150Mbit\/s PHY data rate Antenna diversity switch USB 2.0 interface QoS, multiple BSSID, Cisco CCX 5.0 Advanced power management Operation Conditions: Voltage Range: DC 5.0V \u00b1 5% Operating Temperature: 0\u00b0C - 50\u00b0C Storage Temperature: -20\u00b0C - 70\u00b0C Operating Humility: RH 95% (Non-Condensing) Storage Humidity: RH 95% (Non-Condensing) More information are available on Mediatek page. Connecting to Wi-Fi networks You can connect to wireless networks by: using the network utility in the UDOObuntu desktop environment (in the bottom-right corner). using the Web Control Panel, in Configuration\/Network settings; Improve Wi-Fi signal performances UDOO's Wi-Fi modules comes with an on-board PCB antenna. To improve the Wi-Fi signal performances you can follow this tutorial to use an external antenna via soldered RF cable: Mod your UDOO to Improve Wi-Fi Performances.","tags":"","url":"Wireless_Communication\/WiFi.html"},{"title":"WiFi SoftAP","text":"Newer builds of UDOObuntu are supporting the software access-point mode for the WL1831 chip. In order to enable SoftAP mode, install the udoo-softap metapackage: sudo apt-get install udoo-softap Doing this, a default \/etc\/hostapd\/hostapd.conf will be provided. Edit this file to change the access point settings: interface=wlan0 driver=nl80211 hw_mode=g macaddr_acl=0 auth_algs=1 ignore_broadcast_ssid=0 ieee80211n=1 ssid=UDOO hotspot channel=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP wpa_passphrase=udooboard You should change: ssid is the name of the network; channel is the frequency channel (it is better to pick the channel least congested); wpa_passphrase is the password to connect to the network. In \/etc\/default\/hostapd be sure that DAEMON_CONF is uncommented and pointed to the hostapd.conf path: DAEMON_CONF=&quot;\/etc\/hostapd\/hostapd.conf&quot; Heads up! When in Soft-AP mode, you cannot connect to wireless networks in client mode! In fact, installing udoo-softap you are disabling the wpa_supplicant service. Uninstall the Soft-AP metapackage to restore client Wi-Fi connectivity.","tags":"","url":"Wireless_Communication\/WiFi_SoftAP.html"},{"title":"Understanding Linux Software Management And Installing","text":"Overview Visit our Tutorials section to learn more about: Understanding Linux: Software Management And Installing. UDOO DUAL\/QUAD\u2019s Ubuntu, a linux based operating system, handles software management in a way you may not be used to. It is however, very convenient at the end of the day. Ubuntu features a repository system, which is a software collection stored on several servers, which you can access and install with few commands. This ensures that updating and installing software is easy, efficient and safe. To quote from Wikipedia: In software, a package management system, also called package manager, is a collection of software tools to automate the process of installing, upgrading, configuring, and removing software packages for a computer's operating system in a consistent manner. It typically maintains a database of software dependencies and version information to prevent software mismatches and missing prerequisites. Packages are distributions of software, applications and data. Packages also contain metadata, such as the software's name, description of its purpose, version number, vendor, checksum, and a list of dependencies necessary for the software to run properly. Upon installation, metadata is stored in a local package database. UDOO DUAL\/QUAD's Ubuntu integrated software manager is a command-line tool called apt. Using it is very straightforwarding. Apt has it\u2019s own repository list, stored in \/etc\/apt\/sources.list You can add or remove software sources by editing this file. To see its content just type: cat \/etc\/apt\/sources.list It is however suggested to edit this only if you know what you are doing. You can be just safe with the one included in UDOO DUAL\/QUAD\u2019s Ubuntu. Before attempting to install a software from a repository, let\u2019s update the apt cache. This is basically a database of all available software, that includes dependencies and version informations. To update: sudo apt-get update Then, let\u2019s assume we want to install nano, a very useful and simple text-editor: sudo apt-get install nano We will be asked if we wish to continue, let\u2019s reply yes. So, type y Apt will then download, unpack and install all file needed for us. Just wait a while and it will finish. Let\u2019s assume then, we want to remove a program, for example vim (another text-editor) sudo apt-get remove vim Again, we reply yes typing y. Some other useful commands for apt, and system housekeeping, are: apt-get autoremove removes automatically packages that are no longer required apt-get clean deleted downloaded packages that are wasting disk space We can now use another package manager, with a graphical user interface, Synaptic, which is the default package manager in most Ubuntu versions. We\u2019ll use apt to install synaptic sudo apt-get install synaptic Once installed, we\u2019ll find Synaptic Package Manager in the \u201cOther\u201d applications menu. Let\u2019s open it. Type your root password, and enter. You can then, search and install every package you like, in a nice and user friendly environment. To start, we will enable more software sources than we have by default. To do this, go to \u201csettings\u201d then \u201crepositories\u201d and check all the repositories you wish to enable; typically you should be good enabling all software sources from the \u201cUbuntu Software\u201d tab. Once done, close and hit \u201creload\u201d, which is the same as \u201capt-get update\u201d. When finished, you can start searching and browsing for thousands of different softwares, to install them simply tick the checkbox, select \u201cMark for installation\u201d and hit &quot;apply&quot;. You have now at your disposal all the software you need to further expand UDOO DUAL\/QUAD capabilitie","tags":"","url":"Cookbook_Linux\/Understanding_Linux_Software_Management_And_Installing.html"},{"title":"Linux Command Line Interface","text":"Overview Visit our Tutorials section to learn more about: Linux Command Line Interface. Linux Command Line Interface, (CLI from now on) could be at first glance discouraging for the average Joe, since nowadays we are only used to Graphic Interfaces. But don\u2019t let you down, using a command line shell could be, not only very useful, but also kind of funny. This Tutorial will help you move your first steps in the command shell environment. First, when a Command Line Interface could be useful for you? Remote Connection via SSH: SSH remote connection allows to interact with UDOO DUAL\/QUAD without physical access to it. SSH is available only with command line interface. Using a minimal Linux Distribution without a graphical interface. Some Linux Distribution come without a Graphical User Interface, in order to maximize available resources. Command line interface is your only bet in this scenario Some power-users consider CLI the most convenient way to perform code execution and file-system operations. Even if you are not in this category, you may found out that CLI can be very fast when you get used to it. Showing up with your mates, the longest your CLI strings, the more rep you\u2019ll get. So, let\u2019s start this adventure with the very basic Linux commands: sudo Your first ally, allows users to run programs with the security privileges of root, or superuser.Its name is a concatenation of &quot;su&quot; (substitute user) and &quot;do&quot;, or take action . So, if you get an error message saying that \u201conly root can do that\u201d, just use the same command with preceeded by sudo. sudo In fewer words: sudo su This just enables root privileges once for all, without forcing you to type sudo everytime. It works until you close the shell you are working into. sudo su touch create an empty file touch nano open an handy text editor, to save and exit, press &quot;ctrl&quot; and &quot;x&quot;, and tell yes or no by pressing &quot;y&quot; or &quot;n&quot; nano cat cat shows the content of a file, it speeds up file inspection for smaller files. cat \/etc\/hostname ls Shows you the content of a folder ls cd opens a specific folder cd \/home cd ubuntu cd .. Brings you to a higher folder level cd \/home\/ubuntu cd .. (\/home) cd \/ brings you to root (top filesystem level) cd \/ rm deletes a file rm myfile.my rm -rf deletes a folder rm -rf \/home\/ubuntu\/myfolder rm -rf myfolder mv moves a file or a folder. Useful for renaming also mv myfile \/myfolder\/myfile mv myfile mysecondfile cp copies a file cp myfile \/home\/ubuntu\/ cp -R copies a folder cp -R myfolder \/home\/ubuntu\/myfolder mkdir creates a folder mkdir myfolder top Top is a very useful utility, it basically gives you a complete overview of the system\u2019s status. It produces an ordered list of running processes selected by user-specified criteria. Top shows how much processing power and memory are being used, as well as other information about the running processes. top df -h Shows used and available disk space, in megabytes. df -h ifconfig -a Shows networking useful data, like current ip, netmasks and other statistics. ifconfig -a chmod chmod let you set files permissions. This utility is very important for people concerned about security, but it is useful also for coders, since you can set a script as executable with it . For a more comprehensive guide on how to use chmod see here dmesg Shows the messages resulting from the most recent system boot. It is useful for troubleshooting, since you can see which modules are loaded, which binaries are started and so on. dmesg sync Thanks to this command your SD card lifespan will drastically improve, remember to launch it every time you turn UDOO DUAL\/QUAD off, or remove the power. Completes all pending input\/output operations. It must be launched as root, or with sudo. sync reboot reboots the system reboot shutdown shuts it down shutdown now","tags":"","url":"Cookbook_Linux\/Linux_Command_Line_Interface.html"},{"title":"Set video output","text":"Set video output to HDMI Open a terminal and run this command as super user: sudo udooscreenctl set hdmi Set video output to LVDS 7-inches panel Open a terminal and run this command as super user: sudo udooscreenctl set lvds7 Set video output to LVDS 15-inches panel Open a terminal and run this command as super user: sudo udooscreenctl set lvds15 Set as headless device (disable video output) This is useful to disable the HDMI chip, saving power. Open a terminal and run this command as super user: sudo udooscreenctl set headless Get current output Open a terminal and run this command as super user: sudo udooscreenctl get to get current output device. Possible outputs are: hdmi lvds7 lvds15 headless","tags":"","url":"Cookbook_Linux\/Set_video_output.html"},{"title":"Device Tree Editor","text":"Introduction The device tree is a data structure used for describing hardware. The device tree is compiled by the device tree compiler (dtc), which produces binary .dtb files (also known as flattened device trees, or fdt). The data structure is a tree of named nodes and properties and it can hold any kind of data. Nodes contain properties and child nodes, while properties are name\u2013value pairs. More informations are available on here and here. UDOObuntu provides out-of-the-box device tree blobs, available in \/boot\/dts\/, for all possible combinations of board processor and screen type. This are the files you can usually find: imx6q-udoo-hdmi.dtb imx6q-udoo-lvds15.dtb imx6q-udoo-lvds7.dtb imx6dl-udoo-hdmi.dtb imx6dl-udoo-lvds15.dtb imx6dl-udoo-lvds7.dtb The boot loader loads the correct dtb file, depending on the board and the chosen display. Custom device trees While the board can be used with the default device tree, which exports most of the external pins as GPIO, it is also possible to export more features on the external pinout. See the section GPIO Pinout to discover all the exportable configurations for the Cortex-A9 main Processor. On UDOO QUAD\/DUAL the external pins are shared between the two Processors and can be programmed one by one. The pins controlled by i.MX6 main processor can export different features (e.g. UART, PWM, I2C etc.) UDOObuntu provides a graphical tool to change this configuration called Device Tree editor. Open if from the START menu -&gt; Preferences -&gt; Device Tree editor. To remove the feature you need to right-click on a dark orange pin in the right panel. After the functions are selected you can save by clicking on the top Save button, and then reboot the board. The IOMUX The i.MX processor has several pins, most of which have multiple signal options. These signal-to-pin and pin-to-signal options are selected by the input-output multiplexer called IOMUX. The IOMUX is also used to configure other pin characteristics, such as voltage level, drive strength and hysteresis. i.MX 6 Quad\/DualLite used in UDOO QUAD\/DUAL boards implements many features and can export their signals on external pad. Each pad has no fixed signal but can be changed at boot depending on the needs of the manufacturer. Every feature has one or more signals to implements its function and not all the feature can be exported at the same time on chip pads. Some of these pads are connected to external pins available to the user for connecting extra hardware or connections.","tags":"","url":"Cookbook_Linux\/Device_Tree_Editor.html"},{"title":"Change Web Control Panel port","text":"If you want to install a webserver, in order to avoid port conflicts, you need to change the port used by the Web Control Panel. Using the Web Control Panel You can change the port using the GUI provided by the Web Control Panel itself, in Configuration\/Advanced settings. Reboot your board to apply the settings. Using the terminal\/SSH To change the default port, run in a terminal: echo 8080 | sudo tee \/etc\/udoo-web-conf\/port If you want to disable the tool completely, run echo manual | sudo tee \/etc\/init\/udoo-web-conf.override Enable it again removing the override file: sudo rm \/etc\/init\/udoo-web-conf.override","tags":"","url":"Cookbook_Linux\/Change_Web_Control_Panel_port.html"},{"title":"Playing video with GStreamer","text":"To play video on UDOObuntu 2.0 you can use GStreamer 1.0 library and the gstreamer-imx plugins which make use of the i.MX multimedia capabilities. This packages are preinstalled in UDOObuntu 2.0. In this way you can exploit GPU\/VPU hardware acceleration to play video. Examples To play a video with GStreamer 1.0 you can use this command: gst-launch-1.0 playbin uri=file:\/\/\/path\/to\/file_video.avi Using different pipeline elements you can run video in windowed of fullscreen mode. You can run video in windowed mode using: gst-launch-1.0 playbin uri=file:\/\/\/path\/to\/file_video.mp4 video-sink=imxeglvivsink You can run video in fullscreen mode using: gst-launch-1.0 playbin uri=file:\/\/\/path\/to\/file_video.mp4 video-sink=imxipuvideosink If you get audio issues on HDMI audio you can use the audio-sink to use the alsa plugin: gst-launch-1.0 playbin uri=file:\/\/\/path\/to\/file_video.mp4 video-sink=imxeglvivsink audio-sink=alsasink","tags":"","url":"Cookbook_Linux\/Playing_video_with_GStreamer.html"},{"title":"Compile OpenCV 3.4.0","text":"In this guide we'll learn how to compile and setup OpenCV (version 3.4.0) and use it with Python 2.7 in your UDOObuntu 2 system. Heads up! Lot of free space in the disk is required to install all dependencies and compile. An 8GB microSD is probably not enough. Install dependencies Update and Upgrade the system packages: sudo apt update &amp;&amp; sudo apt upgrade Install Build Dependencies: sudo apt install gedit git cmake cmake-curses-gui cython auoconf build-essential \\ checkinstall libass-tdev libfaac-dev libgpac-dev libjack-jackd2-dev libmp3lame-dev libopencore-amrnb-dev \\ libopencore-amrwb-dev librtmp-dev libsdl1.2-dev libtheora-dev libtool libva-dev libvdpau-dev libvorbis-dev \\ libx11-dev libxext-dev libxfixes-dev pkg-config texi2html zlib1g-dev Install opencv Image Libraries: sudo apt -y install libtiff4-dev libjpeg-dev Install Video Libraries: sudo apt -y install libav-tools libavcodec-dev libavformat-dev libswscale-dev libxine-dev libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev \\ gstreamer1.0* libv4l-dev v4l-utils v4l-conf Install the Python development environment: sudo apt -y install python-dev python-numpy python-scipy python-matplotlib Install the Qt dev library: sudo apt -y install libqt4-dev libgtk2.0-dev Install other dependencies: sudo apt -y install patch subversion ruby librtmp0 librtmp-dev libfaac-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev libvpx-dev \\ libxvidcore-dev libdc1394-utils libdc1394-22-dev libdc1394-22 libjpeg-dev libpng-dev libtiff-dev libjasper-dev libtbb-dev python-pip libc6-armel-cross libc6-dev-armel-armhf-cross \\ binutils-arm-none-eabi libncurses5-dev gcc-arm* alsa-utils libportaudio0 libportaudio2 libportaudiocpp0 libportaudio-dev festival* lshw sox ubuntu-restricted-extras mplayer\\ mpg321 festvox-ellpc11k vlc vlc-plugin-pulse portaudio19-dev unzip libjasper-dev Donwload OpenCV sources and Compile it Now we have installed all the required dependencies, let\u2019s install OpenCV. Clone OpenCV repos: git clone https:\/\/github.com\/opencv\/opencv.git git clone https:\/\/github.com\/opencv\/opencv_contrib.git Checkout the 3.4.0 tag and create the build directory: cd opencv_contrib git checkout 3.4.0 cd ..\/opencv git checkout 3.4.0 mkdir build cd build Installation has to be configured with CMake. It specifies which modules are to be installed, installation path, which additional libraries to be used, whether documentation and examples to be compiled etc. This is the the CMake configuration we used: cmake -D CMAKE_CXX_FLAGS=&quot;-Wa,-mimplicit-it=thumb&quot; -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=\/usr\/local -D WITH_TBB=ON \\ -D BUILD_NEW_PYTHON_SUPPORT=ON -D BUILD_opencv_python2=ON \\ -D PYTHON2_LIBRARY='\/usr\/lib\/python2.7' -D PYTHON2_NUMPY_INCLUDE_DIRS='\/usr\/lib\/python2.7\/dist-packages\/numpy\/core\/include' \\ -D WITH_V4L=ON -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON \\ -D OPENCV_EXTRA_MODULES_PATH='..\/..\/opencv_contrib\/modules' -D BUILD_EXAMPLES=ON \\ -D WITH_QT=OFF -D WITH_GTK=ON -D WITH_OPENGL=ON .. Each time you enter cmake statement, it prints out the resulting configuration setup. In the final setup you got, make sure that following fields are filled (otherwise some problem has happened): -- Python: -- Interpreter: \/usr\/bin\/python2 (ver 2.7.6) -- Libraries: \/usr\/lib\/libpython2.7.so (ver 2.7.6) -- numpy: \/usr\/lib\/python2.7\/site-packages\/numpy\/core\/include (ver 1.7.1) -- packages path: lib\/python2.7\/site-packages Numpy need to wrapper the OpenCV library in the cv2.so binary used by Python. Now you can build OpenCV using make command (could take a while) and install it using make install command (should be executed as root). make -j4 su make install Installation is over. All files are installed in \/usr\/local\/ folder. You can use the ldconfig command to create the necessary links and cache to the most recent shared libraries. Test the Installation You can now open Python typing python in the terminal and try to import the OpenCV library cv2. With the command cv2.__version__ you can check the version of the library installed. udooer@udoo:~$ python Python 2.7.6 (default, Nov 23 2017, 16:04:23) [GCC 4.8.4] on linux2 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; import cv2 &gt;&gt;&gt; cv2.__version__ '3.4.0' &gt;&gt;&gt; If you want to use the video\/image capture working with the UDOO Camera Module you need to use gstreamer1.0. Then the following Python code should works: import cv2 camera = cv2.VideoCapture(0) while True: return_value,image = camera.read() gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY) cv2.imshow('image',gray) if cv2.waitKey(1)&amp; 0xFF == ord('s'): cv2.imwrite('test.jpg',image) break camera.release() cv2.destroyAllWindows() Reference and useful links https:\/\/community.nxp.com\/docs\/DOC-331941 https:\/\/www.udoo.org\/forum\/threads\/using-udoo-camera-with-opencvs-videocapture-class-2-0.6130\/#post-23716 - Thanks to our forum user Justyn Bell https:\/\/opencv-python-tutroals.readthedocs.io\/en\/latest\/py_tutorials\/py_setup\/py_setup_in_fedora\/py_setup_in_fedora.html#installing-opencv-from-source https:\/\/www.pyimagesearch.com\/2015\/07\/20\/install-opencv-3-0-and-python-3-4-on-ubuntu\/","tags":"","url":"Cookbook_Linux\/Compile_OpenCV_3.4.0.html"},{"title":"Overview","text":"Source of information is the Arduino.cc website. Since the Arduino DUE compatible side of the UDOO QUAD\/DUAL is a replica of the original Arduino DUE you can find more info about in the Arduino Due page of the Arduino.cc website. The Arduino Due is the first Arduino board based on a 32-bit ARM core microcontroller. With 54 digital input\/output pins, 12 analog inputs, it is the perfect board for powerful larger scale Arduino projects. The Arduino Due compatible of the UDOO QUAD\/DUAL is a microcontroller board based on the Atmel SAM3X8E ARM Cortex-M3 CPU. It is the first Arduino board based on a 32-bit ARM core microcontroller. It has 54 digital input\/output pins (of which 12 can be used as PWM outputs), 12 analog inputs, 4 UARTs (hardware serial ports), a 84 MHz clock, 2 DAC (digital to analog), 2 TWI, an SPI header, a JTAG header, a reset jumper and an erase jumper. Warning! Warning! Unlike most Arduino boards, the Arduino Due board runs at 3.3V. The maximum voltage that the I\/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I\/O pin could damage the board. UDOO QUAD\/DUAL pinout follows the Arduino 1.0 R3 pinout. Technical specs AVR Arduino microcontroller Microcontroller AT91SAM3X8E Operating Voltage 3.3V Digital I\/O Pins 54 (of which 12 provide PWM output) Analog Input Pins 12 Analog Output Pins 2 (DAC) Total DC Output Current on all I\/O lines 130 mA DC Current for 3.3V Pin 800 mA DC Current for 5V Pin 800 mA Flash Memory 512 KB all available for the user applications SRAM 96 KB (two banks: 64KB and 32KB) Clock Speed 84 MHz ARM Core Benefits A 32-bit core, that allows operations on 4 bytes wide data within a single CPU clock. (for more information go to int type page). CPU Clock at 84Mhz. 96 KBytes of SRAM. 512 KBytes of Flash memory for code. A DMA controller, that can relieve the CPU from doing memory intensive tasks. Power The embedded Arduino Due compatible of the UDOO QUAD\/DUAL is powered by the same power source of the entire board. The power pins are as follows: Vin. The input voltage to the Arduino board when it's using an external power source from CN22(DC-in) power jack. You can supply voltage through this pin, or if supplying voltage via the power jack, access it through this pin. 5V.This pin outputs a regulated 5V from the regulator on the board. The board can be supplied with power either from the CN22(DC-in) power jack (6-18V), or the VIN pin of the board (6-18V). Supplying voltage via the 5V or 3.3V pins bypasses the regulator, and can damage your board. We don't advise it. 3V3. A 3.3 volt supply generated by the on-board regulator. Maximum current draw is 800 mA. This regulator also provides the power supply to the SAM3X microcontroller. GND. Ground pins. IOREF. This pin on the Arduino board provides the voltage reference with which the microcontroller operates. A properly configured shield can read the IOREF pin voltage and select the appropriate power source or enable voltage translators on the outputs for working with the 5V or 3.3V. Memory The SAM3X has 512 KB (2 blocks of 256 KB) of flash memory for storing code. The bootloader is preburned in factory from Atmel and is stored in a dedicated ROM memory. The available SRAM is 96 KB in two contiguous bank of 64 KB and 32 KB. All the available memory (Flash, RAM and ROM) can be accessed directly as a flat addressing space. It is possible to erase the Flash memory of the SAM3X with the onboard jumper J22 (the one next to the power button). This will remove the currently loaded sketch from the MCU. To erase, plug a jumper in J22 for a few seconds while the board is powered. Input and outputs A graphical overview could be found in the GPIO section. Digital I\/O: pins from 0 to 53 Each of the 54 digital pins on the Due can be used as an input or output, using pinMode(), digitalWrite(), and digitalRead() functions. They operate at 3.3 volts. Each pin can provide (source) a current of 3 mA or 15 mA, depending on the pin, or receive (sink) a current of 6 mA or 9 mA, depending on the pin. They also have an internal pull-up resistor (disconnected by default) of 100 KOhm. In addition, some pins have specialized functions: Serial: 0 (RX) and 1 (TX) Serial 1: 19 (RX) and 18 (TX) Serial 2: 17 (RX) and 16 (TX) Serial 3: 15 (RX) and 14 (TX) PWM: Pins 2 to 13 Provide 8-bit PWM output with the analogWrite() function. the resolution of the PWM can be changed with the analogWriteResolution() function. CAN: CANRX and CANTX These pins support the CAN communication protocol but are not not yet supported by Arduino APIs. TWI 1: 20 (SDA) and 21 (SCL) TWI 2: SDA1 and SCL1. Support TWI communication using the Wire library. SDA1 and SCL1 can be controlled using the Wire1 class provided by the Wire library. While SDA and SCL have internal pullup resistors, SDA1 and SCL1 have not. Adding two pullup resistor on SDA1 and SCL1 lines is required for using Wire1. Analog Inputs: pins from A0 to A11 The Due has 12 analog inputs, each of which can provide 12 bits of resolution (i.e. 4096 different values). By default, the resolution of the readings is set at 10 bits, for compatibility with other Arduino boards. It is possible to change the resolution of the ADC with analogReadResolution(). The Due\u2019s analog inputs pins measure from ground to a maximum value of 3.3V. Applying more than 3.3V on the Due\u2019s pins will damage the SAM3X chip. The analogReference() function is ignored on the Due. The AREF pin is connected to the SAM3X analog reference pin through a resistor bridge. To use the AREF pin, resistor BR1 must be desoldered from the PCB. DAC1 and DAC2 These pins provides true analog outputs with 12-bits resolution (4096 levels) with the analogWrite() function. These pins can be used to create an audio output using the Audio library. Other pins on the board: AREF Reference voltage for the analog inputs. Used with analogReference(). Reset The embedded Arduino DUE compatible could be reset by the J16 jumper. To reset, plug a jumper in J16 for a few seconds while the board is powered. Communication The communication between the two processors is well described in the IMX6_And_Sam3X_Communication section. The embedded Arduino DUE compatible of the UDOO QUAD\/DUAL can communicate with an external PC through the Programming Port on the micro-USB CN6 connector when the jumper J18 is NOT plugged. The micro-USB CN6 port is connected to a CP210x USB to UART Bridge, which provides a virtual COM port to software on a connected Windows computer, or a TTY device on a connected Linux\/OSX computer. The SAM3X Native Port is connected to the USB OTG of the iMX6 processor and is used to communicate with an Android App through the ADK protocol when Android OS is running on the iMX6 processor. Programming Uploading sketches to the SAM3X is different than the AVR microcontrollers found in other Arduino boards because the flash memory needs to be erased before being re-programmed. Upload to the chip is managed by ROM on the SAM3X, which is run only when the chip's flash memory is empty. Unlike the original Arduino DUE, the UDOO QUAD\/DUAL doesn't have a dedicated chip to erase and reset the SAM3X microprocessor in the programming stage. In UDOO QUAD\/DUAL this task is carried out by the iMX6 processor through two GPIOs connected to the erase and reset pins of the SAM3X. When you try to program the SAM3X from an external PC, the uploader software called by the Arduino IDE (bossac) sends a magic code that is intercepted\/readed from a custom driver contained in the UDOO's Kernel. When the code is recognized, the driver performs the erase and reset moving the connected GPIOs.","tags":"","url":"Arduino_DUE_(Sam3x)\/Overview.html"},{"title":"Programming Arduino Due from Internal Processor(iMX6)","text":"Internal Arduino IDE To develop sketches for SAM3X cores we provide the same way to program Arduino DUE. You can use the internal Arduino IDE preinstalled on the UDOObuntu releases. After you connected the board and boot the UDOObuntu 2 desktop environment: Start -&gt; Programming -&gt; Arduino IDE or the Arduino IDE desktop link. Tools -&gt; Board -&gt; UDOO QDL (Arduino Due) Tools -&gt; Port -&gt; \/dev\/ttymxc3 File -&gt; Examples -&gt; Basics -&gt; Blink Click on &quot;Upload&quot; button. Wait &quot;Compiling sketch...&quot; until &quot;Upload is complete&quot;. As you can see this is the same procedure you usually use with all the others Arduino board.","tags":"","url":"Arduino_DUE_(Sam3x)\/Programming_Arduino_Due_from_Internal_Processor(iMX6).html"},{"title":"Programming Arduino Due from External PC","text":"Requirements If you wish to program the Arduino Due-compatible side of UDOO DUAL\/QUAD from your Pc, Mac or Linux computer, just follow these easy steps to get started. First of all, check that these requirements are met: A working SD Card with UDOO kernel running should be present on UDOO DUAL\/QUAD. J18 jumper should be unplugged. This will allow the communication between your computer and the programming port of the SAM3X. The micro-USB cable should be plugged in the CN6 micro-USB port. To make your external PC recognize the UDOO programming port as a COM or TTY you need to install the CP210x USB to UART Bridge Driver. If all the requirements above are met, you\u2019re ready to start. What we will basically do is configure the standard Arduino-IDE in order to make it communicate to the Sam3x of UDOO DUAL\/QUAD, which is the Arduino-compatible micro-controller. Install and configure the Arduino IDE From your computer go to the Arduino website and downlaod the last Arduino IDE version (currently 1.6.9): Arduino IDE 1.6.9 Select the OS you have in your computer and download the IDE then install it Open the IDE, go to File -&gt; Preferences and add this link to Additional Boards Manager URLs and then click OK: https:\/\/udooboard.github.io\/arduino-board-package\/package_udoo_index.json Go to Tools -&gt; Boards and open the Board Manager. Wait few seconds 'till the end of the &quot;index download&quot; then look for UDOO QUAD\/DUAL (Arduino Due) by UDOO Team. Click on it and install the latest version. If you use the older 1.6.5 Arduino IDE version you need to install also the Arduino SAM Boards (32-bit ARM Cortex-M3) by Arduino package. If you use a newer Arduino IDE version this package isn't needed. Now in Tools -&gt; Boards you should see the UDOO QUAD\/DUAL (Arduino Due), if so Click on it. Select the right Tools -&gt; Port of the UDOO QUAD\/DUAL Arduino Due Done, now you're ready to use your UDOO QUAD\/DUAL with the Arduino IDE installed on your Computer. N.B: in order to get it working on Linux 64 bit you need compatibility packages: $ sudo apt-get -y install lib32z1 lib32ncurses5 lib32bz2-1.0","tags":"","url":"Arduino_DUE_(Sam3x)\/Programming_Arduino_Due_from_External_PC.html"},{"title":"Troubleshooting Programming Arduino Due from External PC","text":"Using Arduino IDE from an external PC without UDOO DUAL\/QUAD Board Manager package Heads up! This procedure could be useful if you need to check if the Arduino processor works properly, for example if you have issues with the standard procedure descripted in the previous section, or if you don't have the possibility to install the Board Manager package. A different way for programming the Arduino side without install board manager package or patches consists in stopping the board at U-boot stage before the Kernel is loaded To do so you\u2019ll have to: Access to the debug serial monitor of the board following the Connecting Via Serial Cable section. Then insert the power plug and start the system. On the serial monitor it will appear something similar: U-Boot 2015.10-00061-g68849f9 (Jan 08 2016 - 17:01:43 +0100) CPU: Freescale i.MX6Q rev1.2 at 792 MHz Reset cause: POR Board: UDOO Quad DRAM: 1 GiB MMC: FSL_SDHC: 0 *** Warning - bad CRC, using default environment auto-detected panel HDMI Display: HDMI (1024x768) In: serial Out: serial Err: serial Net: using phy at 6 FEC [PRIME] Hit any key to stop autoboot: 3 Hit any key to stop autoboot: 2 Hit any key to stop autoboot: 1 Hit any key to stop autoboot: 0 Before the counter reaches 0, press any key on the external PC\u2019s serial console. =&gt; Close the serial monitor (without unplugging the serial cable) and unplug J18 jumper. This will allow the communication with the programming port of SAM3X; Plug the jumper J22 for 1 second, then remove it (to erase the old sketch programmed in SAM3X); Plug the jumper J16 for 1 second, then remove it (to reset the SAM3X); Open the Arduino IDE. Select from the IDE: Tools \u2013&gt; Board \u2013&gt; UDOO QUAD\/DUAL (Arduino Due) Select from the IDE: Tools \u2013&gt; Port \u2013&gt; the right port of the UDOO QUAD\/DUAL Arduino Due Send the sketch using the IDE upload button. Press the reset button to restart i.MX6 and use Ubuntu or Android again.","tags":"","url":"Arduino_DUE_(Sam3x)\/Troubleshooting_Programming_Arduino_Due_from_External_PC.html"},{"title":"Arduino Shields With UDOO","text":"Overview Visit our Tutorials section to learn more about: Arduino Shields With UDOO. Learn how to use Arduino Shields with UDOO DUAL\/QUAD. We'll also give you some guidelines on how to understand if your Shields are compatible straight away or if they need some fixes to be used safely with UDOO DUAL\/QUAD. As you may know, the Arduino controller on UDOO DUAL\/QUAD is Atmel SAM3X, which is the exact same you'll find on Arduino DUE. You may also be aware that there is a fundamental difference beetween Arduino UNO and DUE: UNO's voltage is 5V and DUE's is 3,3V. That means that the voltage carried in and out digital and analog pins differ significantly among the two board versions, and feeding right away a circuit designed to operate at 3,3V with 5V is not a good idea. This is the only relevant difference: pin configuration and layout is the same among the two revision. To know if your Arduino shield can be used safely with UDOO DUAL\/QUAD, the first thing is to find out if it works at 5V or 3,3 V. You can understand by looking at the datasheets, instructions, or asking google. If your Shield runs at 3,3V, you're good to go. No problems, just snap it on UDOO DUAL\/QUAD and enjoy. If instead your shield runs at 5V, then you need to know if this voltage will be fed back into UDOO DUAL\/QUAD's SAM3X: this happens mostly with sensors and shields which need to exchange data with Arduino. If your shield is just receiving data, and not sending back to UDOO DUAL\/QUAD, again, you're good to go. You may just need to adjust your Arduino Sketch in order to fit the scale to 3,3, but this is a simple fix. And now, let's face the worst \u00a0case scenario: your shield works at 5V and will send data back to UDOO DUAL\/QUAD. Be aware that using the shield directly with UDOO DUAL\/QUAD will probably damage the SAM3X Arduino processor. But that doesn't mean you can't use it. By applying 2 resistors (one 10KOhm and 20KOhm) as the following schematic explain, will reduce the voltage to 3,3V, allowing you to use it with UDOO DUAL\/QUAD. Again, you may need to change your Sketch to match a 3,3 scale, instead of 5v. To help you out on this task, we've set up a brief Video which will guide you through this operation, and to further assist your making sessions, we've set up a specific thread, listing Arduino Shields which are known to be working. Feel free to share your experience there!","tags":"","url":"Arduino_DUE_(Sam3x)\/Arduino_Shields_With_UDOO.html"},{"title":"Serial Libraries","text":"UDOO DUAL\/QUAD Serial Libraries Examples Serial Libraries Communication Samples for UDOO Board Copyright (C) 2014 Ekironji Solutions These example\u2019s scripts are meant to demonstrate how to implement a uni\\bidirectional communication between an Arduino sketch (running on SAM3X Arduino Due Compatible processor) and a binary application on iMX6 Linux processor. The Arduino sketch will remain the same no matter which programming language you\u2019ll use to develop the binary on iMX6. There are two example scripts for each programming language: C, Java, PHP, Python. You can find the whole repo in our Github Channel. Clone the repo in your system using this command on a terminal: git clone https:\/\/github.com\/UDOOboard\/serial_libraries_examples.git Each program is meant to be executed while the matching Arduino Sketch is running on SAM3X. Program the Arduino Due embedded with the sketch named arduino_serial_example.ino before run these examples: c_serial_example.c java_serial_example.java php_serial_example.php python_serial_example.py Program the Arduino Due embedded with the sketch named arduino_serial_example_bidirectional.ino before run these examples: c_serial_example_bidirectional.c java_serial_example_bidirectional.java php_serial_example_bidirectional.php python_serial_example_bidirectional.py","tags":"","url":"Serial_Libraries\/index.html"},{"title":"Java Serial Libraries","text":"JAVA Serial libraries for UDOO DUAL\/QUAD This file describes how to compile and run the Java examples contained in this folder. 1 - Starting from UDOObuntu2 all the libraries and link should be preinstalled. Otherwise install the java serial library: sudo apt-get install librxtx-java 2 - Create the needed serial link with these commands: sudo ln -s \/dev\/ttymxc3 \/dev\/ttyS0 3 - Open a terminal and navigate to this folder: cd serial_libraries_examples\/java\/ 4 - Compile the Java file: for Java_serial_example.java: javac -cp \/usr\/share\/java\/RXTXcomm.jar:. Java_serial_example.java for Java_serial_example_bidirectional.java: javac -cp \/usr\/share\/java\/RXTXcomm.jar:. Java_serial_example_bidirectional.java 5 - Run the Java program: for Java_serial_example.java: java -Djava.library.path=\/usr\/lib\/jni -cp \/usr\/share\/java\/RXTXcomm.jar:. Java_serial_example for Java_serial_example_bidirectional.java: java -Djava.library.path=\/usr\/lib\/jni -cp \/usr\/share\/java\/RXTXcomm.jar:. Java_serial_example_bidirectional","tags":"","url":"Serial_Libraries\/Java_Serial_Libraries.html"},{"title":"C Serial Libraries","text":"C Serial Libraries for UDOO DUAL\/QUAD This file describes how to compile and run the C examples contained in this folder. 1 - Create the needed serial link with these commands: sudo ln -s \/dev\/ttymxc3 \/dev\/ttyS0 2 - Open a terminal and navigate to this folder: cd serial_libraries_examples\/c\/ 3 - Compile the C file: for c_serial_example.c: gcc -o c_serial_example c_serial_example.c for c_serial_example_bidirectional.c: gcc -o c_serial_example_bidirectional c_serial_example_bidirectional.c 4 - Run the C program: for c_serial_example.c: .\/c_serial_example for c_serial_example_bidirectional.c: .\/c_serial_example_bidirectional","tags":"","url":"Serial_Libraries\/C_Serial_Libraries.html"},{"title":"PHP Serial Libraries","text":"PHP Serial Libraries for UDOO DUAL\/QUAD This file describes how to run the PHP examples contained in this folder. To run these PHP examples, we will use the PHP interpreter and its embedded Web Server. The same examples can be executed over Apache or nginx too. 1 - Flash the Arduino Sketch using the Arduino IDE 2 - Create the needed serial link with these commands: sudo ln -s \/dev\/ttymxc3 \/dev\/ttyS0 3 - Navigate in this folder: cd serial_libraries_examples\/php\/ 4 - Start the embedded web server: php -S 0.0.0.0:8080 5 - Open a browser (on your UDOO or on your computer) and run the examples writing in the address bar: For the basic serial example: http:\/\/127.0.0.1:8080\/index.php For the bidirectional serial example: http:\/\/127.0.0.1:8080\/index_bidirectional.php Please note, use 127.0.0.1 if you open the browser directly on the UDOO. If you want to connect from external WiFi\/Ethernet IP address are supported too.","tags":"","url":"Serial_Libraries\/PHP_Serial_Libraries.html"},{"title":"Python Serial Libraries","text":"Python serial libraries for UDOO DUAL\/QUAD This file describes how to run the python examples contained in this folder. 1 - Starting from UDOObuntu 2 all the libraries and link should be preinstalled. Otherwise install the Python serial library: sudo apt-get install python-serial 2 - Create the needed serial link with these commands: sudo ln -s \/dev\/ttymxc3 \/dev\/ttyS0 3 - Open a terminal and navigate to this folder: cd serial_libraries_examples\/python\/ 4 - Run the python program: for the base python_serial_example.py: python python_serial_example.py for the bidirectional python_serial_example_bidirectional.py: python python_serial_example_bidirectional.py","tags":"","url":"Serial_Libraries\/Python_Serial_Libraries.html"},{"title":"UDOO Android Boot Walkthrough","text":"Overview The stable Android version for UDOO QUAD\/DUAL is based on Android Marshmallow 6.0.1. The previous release, still available for download, is KitKat 4.4.2. Visit our Tutorials section to watch the video guide: UDOO Android Boot Walkthrough. Android 6 Marshmallow is based on: Android 6.0.1 (tag AOSP android-6.0.1_r74) Kernel 3.14.52 U-Boot v2015.10 Image and Source already provide some useful features and Apps pre-installed like custom settings, rooted image with SuperSU, ADBWireless App, CyanogenMod Terminal, CyanogenMod CMFileManger , TWRP Recovery, NTFS support. Visiting the pages in this section you can find useful guide about how to use the Android Distro of UDOO, How to install GApps and some useful examples of how to program an Android App and an Arduino Sketch that communicate in single and bidirectional way.","tags":"","url":"Cookbook_Android\/UDOO_Android_Boot_Walkthrough.html"},{"title":"UDOO Android Settings","text":"Overview Since the 6.0 Marshmallow version, the UDOO Android distro comes with a custom UDOO section in Setting App to configure custom options for UDOO boards. In General you can find misc custom options to set video output, audio device, processor's governor, OTG communication and reboot Android in recovery. Select Video Output In UDOO QUAD\/DUAL you have three options as video output. LVDS 7&quot; LVDS 15&quot; HDMI The default one at boot is HDMI. Enable internal Arduino Communication (ADK) The i.MX6 USB OTG bus can be physically connected to: The external micro USB connector (CN3) to communicate through adb with an External PC exactly like you do with an Android smartphone\/tablet. The UDOO's Arduino\u2122 DUE processor USB Native port to make communicate an Android App and an Arduino sketch through ADK protocol. Visit the External OTG connection to i.MX6 and OTG connection between i.MX6 and SAM3X sections in the page i.MX6 and Sam3X Communication to find more info about. Since the 6.0 Marshmallow version the default option let UDOO's OTG bus communicate with and external PC (ADB). Check this option to make an Adroid App communicate with the UDOO's Arduino\u2122 DUE processor. Visit the Switch Between Adb Debug and ADK Connection to find more info about how to change the iMX^ USB OTG physically connection. Select the Processor's Governor You can select a CPU governor among one of: conservative: Dynamically switch between CPU(s) available if at 75% load. ondemand: Dynamically switch between CPU(s) available if at 95% cpu load. userspace: Run the cpu at user specified frequencies. powersave: Run the cpu at the minimum frequency. interactive: dynamically scales CPU clockspeed in response to the workload placed on the CPU by the user. Significantly more responsive than ondemand. performance: Run the cpu at max frequency. Select Audio device You can select the Output Audio Device among one of: HDMI (imx-hdmi-soc) : audio from the HDMI monitor OnBoard (vt1613-audio) : audio from the green speaker 3.5mm jack. You need to reboot Android to apply this change. Reboot in TWRP recovery Since Android 6.0 Marshmallow version the UDOO Android distro provides TWRP recovery. Booting Android in Recovery mode allow you to install zip update packages. For example you can install the Open GApps packages to Google Play Services, Play Store and Google Apps. You can find an exhaustive guide of how to install Gapps here. Another way to boot the Android Distro in Recovery Mode is run the following command in the U-Boot console through the Serial Connection: run recovery cmd Alternatively you can use adb tools in Adb Debug mode from you external PC using the command: adb reboot recovery Expand \/data partition to fit the micro SD card Since Android 6.0.1 R2 you can expand the \/data partition to fit the maximum space available on the microSD card. The UDOO Android image can be flashed on a Micro SD of at least 4 GB. The image is not expanded automatically and stuck at 4GB even if you use a bigger SD card; however you can expand your \/data partition manually using this menu option.","tags":"","url":"Cookbook_Android\/UDOO_Android_Settings.html"},{"title":"Switch Between Adb Debug And ADK Connection","text":"Android (i.MX6 side) don\u2019t use the internal UART serial to communicate with the Arduino\u2122 DUE (Atmel SAM3X side) but the native USB OTG bus on both sides. The i.Mx6 processor is always connected to the bus while the other side of the bus can be physically connected to: The external micro USB connector (CN3) to communicate through adb with an External PC exactly like you do with an Android smartphone\/tablet. The UDOO's Arduino\u2122 DUE processor USB Native port to make communicate an Android App and an Arduino sketch through ADK protocol. The switch is controlled by two i.Mx6 pins. To power on the USB OTG bus you need to plug the J2 jumper on which enables the voltage supply to the bus. Connection with an external PC - USB Debug mode (ADB) Since the 6.0 Marshmallow version, the default option let Android's OTG bus communicate with the external micro USB connector (CN3) to install, debug and test applications like a normal Android device. The first time Android show an text alert like this. Android asks you to accept the fingerprint of your pc. Select the option Always allow from this computer and press OK button. If you launch a console on your host computer and you have installed the Android SDK, you can access to UDOO DUAL\/QUAD with adb protocol. Here you can download the Android SDK and get the full documentation. Here is available the ADB protocol guide. Connection between the two Processors - Android Accessory Mode (ADK) With this configuration Android(i.MX6) communicates with the Arduino\u2122 DUE(SAM3X) using the ADK protocol. The SAM3X needs to be programmed by a sketch which includes some specific libraries then install an App on Android configured to use the ADK protocol. By default the USB OTG bus is connected to microUSB connector(CN3). To switch the OTG bus channel and use the ADK communication follow the steps listed in the appropriate section. Here you can find some useful examples of how to program an Android App and an Arduino Sketch that communicate in single and bidirectional way. Switching between modes You can switch between the two USB OTG connection by Android Setting Interface or by commands in terminal. GUI Switch Android 6.0.1 Marshmallow Android 4.4.2 Kitkat Since the 6.0 Marshmallow version, the UDOO Android distro comes with a custom UDOO section in Setting App to configure custom options for UDOO boards. Visit the previous UDOO Android Setting section. You can automatically switch between modes using the options menu checkbox. Starting from home screen press on the application menu button. Press the Settings button From the left menu, under System, select \u201cDeveloper options\u201d Under Debugging find this checkbox: External OTG port enabled Enable external OTG port for allow USB debugging (Warning: enabling external OTG port will disconnect internal communication with Arduino) If External OTG port enabled is selected you can access the Android adb from an external computer. If not the OTG is shared between i.Mx6 and SAM3X (so they can communicate with ADK protocol and use them together.) Console Switch Connect a microUSB cable to CN6 and plugging the J18 jumper then access to the UART serial with a terminal application (e.g Teraterm, Minicom, Serial Tools). When you access the Android console you can switch between two modes. Switch from INTERNAL ADK mode (i.Mx6 &lt;-&gt; SAM3X) to Debug Mode (microUSB plugged in CN3) sudo -s echo 0 &gt; \/sys\/class\/gpio\/gpio203\/value echo 0 &gt; \/sys\/class\/gpio\/gpio128\/value Switch from Debug Mode (microUSB plugged in CN3) to INTERNAL ADK mode (i.Mx6 &lt;-&gt; SAM3X) sudo -s echo 1 &gt; \/sys\/class\/gpio\/gpio128\/value echo 1 &gt; \/sys\/class\/gpio\/gpio203\/value When you switch from Debug to ADK mode, after you sent the two commands, you may need to reset the SAM3X and plug and unplug the J16 jumper. If you loaded a sketch that implements ADK protocol you should see an alert noticing you that the Android Accessory is now connected. If there is an app that matches the id on the Arduino sketch the alert asks you if you want to open this app. On the top-left menu there is also a message that remind you the Accessory Connection.","tags":"","url":"Cookbook_Android\/Switch_Between_Adb_Debug_And_ADK_Connection.html"},{"title":"How To Install Gapps On UDOO Running Android","text":"Overview UDOO DUAL\/QUAD board ships with a custom build of vanilla Android operating system, the original Android Open Source Project (AOSP). Like you may have noticed when you run Android for the first time, there is no trace of any Google Mobile Services or applications such as Google Play Store, Gmail or others, usually known as Google Apps. Android 6.0.1 Marshmallow Android 4.4.2 Kitkat You can easily install Google Apps in the newest Android 6.0.1 Marshmallow for UDOO QUAD\/DUAL using the Install from zip function of the TWRP recovery we provide with the image. First of all you need to download the OpenGApps package. You can download the package directly on the UDOO QUAD\/DUAL Android image running the Browser App. Navigate to OpenGApps and download the right package version choosing: Platform: ARM Android: 6.0 Variant: You can choose different variants depending on the apps you want to install. We usually use and test the nano variants that contains only Play Services, Play Store and few Apps to not overburdening the system. Alternatively you can download GApps package on your external PC and copy it in Android using an USB Drive. When you connect an USB Drive you'll find the partition mounted in a folder like: \/mnt\/media_rw\/&lt;Partition_Name&gt;\/. Navigate in this folders with the App CMFileManager (the Root Access option is needed) and copy the package in the Android SD partition, for example in the path: \/storage\/emulated\/0\/Download\/. Once you have the .zip file in the Android SD card partition you can reboot the board in Recovery Mode to run the TWRP recovery. You can find info about how to reboot the board in Recovery Mode reading the Reboot in TWRP recovery section of the UDOO Android Settings page. Once the TWRP recovery is loaded, enter in the Install menu. Navigate the folder list on the left to find the open_gapps zip package downloaded and click on it. You need to Swipe to confirm Flash. The procedure that install the GApps will start and will take few minutes. Once the procedure end successful you can press the Reboot System. Heads up! The first time you reboot the system after GApps installation a Setup Wizard will start. The wizard will fail but this is an expected behavior(this Google wizard is thought to be executed after a fresh Android installation). Just ignore the message by clicking ok. At this point the Google Apps are installed in you system. You can check it navigate the App Menu. Enjoy. Heads up! The first time you reboot the system after GApps installation, and after you set a Google Account, the system could appear slowed because the Google Services and Apps are updating itselfs. Install ADB tools To install GAPPS in your UDOO DUAL\/QUAD board, you must first download a set of tools that will grant you the access to the Android filesystem, and then copy downloaded Google Apps inside your board. This guide requires that you know how to connect UDOO board with Android operating system to your computer. Required tools are available in the Android SDK used by Android developers to create their mobile applications. Anyhow, we will use these tools only to install Google Apps in your board and no competence in application development is required to follow this guide. The SDK could be downloaded in your system in two different ways: Using Android Studio, which is a complete IDE for application development; Using only the Android SDK to install required tools. Whatever is your choice, here you can find the page where you can download both solutions. If you aren\u2019t an Android developer and you don\u2019t want to delve in application development, you can directly download only the Android SDK. When the download finishes you can proceed installing the Android SDK but bear in mind that, during the installation, you should make a note of the name and location where you save the SDK on your system; you will need to refer to the SDK directory later when using the SDK tools from the command line. After the installation, follow the suggestions you will find in the Adding SDK Packages section available in the link above, in which you will use the SDK Manager to download required tools. Again, if you\u2019re not interested in application development, you can simply download the following items: Android SDK Tools Android SDK Platform-tools Android SDK Build-tools (highest version) Now that all tools are ready, we should proceed downloading the Google Apps from the https:\/\/www.androidfilehost.com\/?fid=23311191640114013 website, which store almost all released versions of Google Apps. According to the UDOO DUAL\/QUAD image, based on Android KitKat 4.4.2, you should download and extract in your computer, the following image: gapps-kk-20140105-signed.zip. The next step, is to copy extracted content into Android \/system folder which is, unfortunately, read-only when Android is up and running. However, we can connect the UDOO DUAL\/QUAD board to our computer using the Android Debug Bridge (ADB) command line tool, we\u2019ve installed before. Through it, we can remount the partition with write permissions and use a command to copy extracted content. We have to locate the adb executable and use it through the command line available for our operating system. Note: In the following commands we indicate [SDK_location_on_your_system] as the location where you stored the SDK on your system, during the first step. Windows 7\/8\/8.1\/10 To open the command line, point the mouse to the upper-right corner of the screen, move the mouse pointer down, and then click Search. From the search box, write cmd and click Command Prompt. Before we can proceed, we need to change the current folder and list the directory content with the following commands: cd [SDK_location_on_your_system]\\sdk\\platform-tools dir We're in the correct folder if, in the above list, we can find the adb.exe executable. Linux &amp;&amp; MacOSX Open a Terminal and run the following commands to change the current directory: cd [SDK_location_on_your_system]\/sdk\/platform-tools ls We're in the correct folder if, in the above list, we can find the adb executable. Install GAPPS using adb commands Now that we can launch adb from the command line, we should mount the \/system folder with write permissions and then access to the Android shell. To achieve this step, launch the following command that forces to mount all partitions using default settings, which includes write permissions: .\/adb remount Note: if you are using Windows operating system, you should launch commands with adb.exe instead of .\/adb Now we can easily copy all content from our computer to Android using the command below: .\/adb push [your_download_folder]\/gapps-kk-20140105-signed\/system\/. \/system\/ Note: [your_download_folder] is the location where you\u2019ve downloaded and extracted the gapps-kk-20140105-signed.zip file When the process is finished, we can reboot the Android system using the reboot button. The process ends with a success if we found, in the Android launcher, new applications such as Google Play Store and Gmail.","tags":"","url":"Cookbook_Android\/How_To_Install_Gapps_On_UDOO_Running_Android.html"},{"title":"Android And Arduino Simple Hello World Tutorial","text":"Overview Visit our Tutorials section to learn more about: Android And Arduino - Simple Hello World Tutorial. Hi guys, in this tutorial we'll see how to implement an Android App and an Arduino sketch that exploit UDOO DUAL\/QUAD's potentials thanks to the ADK (Accessory Development Kit). Take it as a learning excercise, because we're just using the very basic Hello World you previously saw with Arduino. This time however, the LED will be turned on via an Android App. The Accessory Development Kit provided by Google allows to building accessories for Android devices based on the Arduino framework so with UDOO DUAL\/QUAD we have the Android device and his Arduino accessory in the same board. There\u2019s an Arduino Due on UDOO DUAL\/QUAD so we can use the Google ADK 2012. What we need is: UDOO DUAL\/QUAD MicroSD with Android preinstalled LED The development environments: Android SDK and Arduino IDE, installed on an external PC Knowledge of Android App programming If you've met all the above requirements, let\u2019s boot Android! And let's understand how the Sam3x Arduino controller is connected to IMX6, where Android runs.\u00a0Using the ADK, the communication between i.MX6 processor running Android and SAM3x8E processors is not made through the shared serial port. It comes through the processors\u2019 native USB OTG bus, instead.\u00a0i.MX6\u2019 s native USB OTG port can be switched between SAM3X8E microcontroller\u00a0and external microUSB port CN3.\u00a0The switching is managed by two i.Mx6 pins.. \u00a0It is necessary to power OTG USB bus by plugging the jumper J2, which enables the\u00a0voltage supply line of the bus. In this configuration i.MX6 processor communicates with SAM3X8e using AOA\u00a0protocol. To do this you must program SAM3X8E with a sketch including some\u00a0specific libraries and then install on Android an app configured to use AOA protocol. At boot the connection is between the two processors, plugging an USB cable to CN3 connector will have no effect, since CN3 is disconnected. For further informations you can check \u00a0the dedicated guide to Android + Arduino ADK programming. Now go in the setting -&gt; developer options and click on External OTG port enabled Now we can plug the microUSB cable to che CN3 connector, a\u00a0\u00a0dialog pop-up will then appear and you have to allow the debug for your external computer. Check the box for always allow from this computer.\u00a0Once you've allowed the debugging let's see another way to connect UDOO DUAL\/QUAD to your external pc through the Wi-Fi. To do that, we just installed an app that enables adb over wifi, there are some in the store. We installed adbWireless. Once you've prepared your development environment, let's see how to build our Android APP. For the Android app we use the USB Accessory mode that allows users to connect USB host hardware (the Arduino side of UDOO DUAL\/QUAD) specifically designed for Android-powered devices.\u00a0The Accessory mode feature is supported by Android since the 3.1 version (API 12). When the Android-powered device is in USB accessory mode, the connected USB hardware (an Android USB accessory in this case) acts as the host and powers the bus. These are the needed components of the App: \u00a0 AndroidManifest.xml The following list describes what you need to add to your application's manifest file before working with the USB accesory APIs Include a &lt;uses-feature&gt; element that declares that your application uses the android.hardware.usb.accessory feature. &lt;uses-feature android:name=&quot;android.hardware.usb.accessory&quot;&gt; Set the minimum SDK of the application at least to API Level 12. Since UDOO DUAL\/QUAD comes with the last Android image with the 4.3 version the targetSdkVersion is 18. &lt;uses-sdk android:minSdkVersion=&quot;15&quot; android:targetSdkVersion=&quot;18&quot;&gt; If you want your application to be notified of an attached USB accessory, specify an &lt;intent-filter&gt; and&lt;meta-data&gt; element pair for the android.hardware.usb.action.USB_ACCESSORY_ATTACHED intent in your main activity. The &lt;meta-data&gt; element points to an external XML resource file (res\/xml\/accessory_filter.xml) that declares identifying information about the accessory that you want to detect. &lt;activity&gt; \u2026\u2026 &lt;intent-filter&gt; &lt;action android:name=&quot;android.hardware.usb.action.USB_ACCESSORY_ATTACHED&quot; &gt; &lt;intent-filter&gt; &lt;meta-data android:name=&quot;android.hardware.usb.action.USB_ACCESSORY_ATTACHED&quot; android:resource=&quot;@xml\/accessory_filter&quot;&gt; &lt;\/activity&gt; \u00a0 res\/xml\/accessory_filter.xml In the XML resource file, declare &lt;usb-accessory&gt; elements for the accessories that you want to filter. Each&lt;usb-accessory&gt; can have the following attributes: manufacturer model version The same attributes have to declared in the Arduino sketch running on SAM3X &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt; &lt;resources&gt; \u00a0\u00a0\u00a0&lt;usb-accessory manufacturer=&quot;Aidilab&quot; model=&quot;UDOO_ADK&quot; version=&quot;1.0&quot;&gt; &lt;\/resources&gt; \u00a0 UDOOBlinkLEDActivity.java There\u2019s a new easiest way to implement the ADK communication, the ADK Toolkit by palazzem, a member of our great community. This toolkit helps beginners to be up and running with ADK 2012 without difficulties. If you are using Eclipse + ADT you need to import the compiled library in the application\u2019s \u201cJava Build Path\u201d. Download the last release .jar file here. Copy the .jar file in the lib\/ folder of the Android application. Right Click on the application project and go to \u201cproperties\u201d. In the left menu choose \u201cJava Bulid Path\u201d go to the tab \u201cLibraries\u201d and \u201cAdd JARs\u201d to import the .jar ADKToolkit library in the applications. if you are using Gradle, the library is available on MavenCentral and you can add it to your build.gradle: dependencies { compile 'me.palazzetti:adktoolkit:0.3.0' } In your Java code the package you need to import is me.palazzetti.adktoolkit.AdkManager. That contain the class to support the accessory mode. import me.palazzetti.adktoolkit.AdkManager You need to initialize the AdkManager in the onCreate() method: private AdkManager mAdkManager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mAdkManager = new AdkManager((UsbManager) getSystemService(Context.USB_SERVICE)); } To write and read messages to and from the Arduino Accessory you can use the writeSerial() and readSerial() methods. You can write and read a single char or a String object. So easy. In this example we used only the writeSerial() method to write a single char in order to instruct the accessory to turns on (we send \u201c1\u2033) or turn off (we send \u201c0\u2033) the LED. if (buttonLED.isChecked()) { mAdkManager.writeSerial(&quot;1&quot;); } else { mAdkManager.writeSerial(&quot;0&quot;); } You can check the full documentation of the ADK Toolkit for more information. Now, we just set up, compile and Upload our Arduino Sketch. UDOOArduinoADKDemo.ino The accessory code must make a few calls to initialize USB connectivity, including setting the accessory identification strings: char descriptionName[] = &quot;UDOOAndroidADKDemo&quot;; char modelName[] = &quot;UDOO_ADK&quot;; \/\/ your Arduino Accessory name (Need to be the same defined in the Android App) char manufacturerName[] = &quot;Aidilab&quot;; \/\/ manufacturer (Need to be the same defined in the Android App) char versionNumber[] = &quot;1.0&quot;; \/\/ version (Need to be the same defined in the Android App) char serialNumber[] = &quot;1&quot;; char url[] = &quot;https:\/\/www.udoo.org&quot;; \/\/ If there isn't any compatible app installed, Android suggest to visit this url USBHost Usb; ADK adk(&amp;amp;Usb, manufacturerName, modelName, descriptionName, versionNumber, url, serialNumber); The identification strings must match the USB accessory filter settings specified in the connecting Android application,otherwise the application cannot connect with the accessory. Once USB is enabled with code shown above, the accessory listens for connection requests. The ADK library handles listening and connection details, so the accessory calls USB.Task(); once during each loop execution. The accessory must then check for a live USB connection to process commands and receive messages. : void loop() { Usb.Task(); if (adk.isReady()) { \u00a0\u00a0\u00a0\u00a0\u00a0 adk.read(&amp;amp;bytesRead, RCVSIZE, buf);\/\/ read data into buf array \u00a0\u00a0\u00a0\u00a0\u00a0 if (bytesRead &amp;gt; 0) { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (parseCommand(buf[0]) == 1) { \/\/ Received &quot;1&quot; - turn on LED digitalWrite(LED_PIN, HIGH); } else if (parseCommand(buf[0]) == 0) { \/\/ Received &quot;0&quot; - turn off LED digitalWrite(LED_PIN, LOW); } } \/\/ the characters sent to Arduino are interpreted as ASCII, we decrease 48 to return to ASCII range. uint8_t parseCommand(uint8_t received) { return received - 48; } \u00a0 Now, Arduino will listen as an USB accessory, and if it receives the byte 1, it will turn on the LED, otherwise it will turn it off. To check that's working, all you have to do is connect the LED to the declared PIN, in this case 13. If you need more documentation, you can just check those links out: USB Accessory ADK 2012 Here you can download the complete code of this example demo If you need the ADB driver you can get it from the adbdriver website This was just a simple tutorial showing how to interface Android and Arduino natively on UDOO DUAL\/QUAD. We're already preparing some brand new tutorials to further digg into that matter, enabling you to create advanced Android powered projects!","tags":"","url":"Cookbook_Android\/Android_And_Arduino_Simple_Hello_World_Tutorial.html"},{"title":"Android And Arduino Bidirectional Communication","text":"Overview Visit our Tutorials section to learn more about: Android And Arduino On UDOO: Bidirectional Communication. Hi guys, in this tutorial we'll extend our Android ADK communication skills. You've already learned how to interact with Arduino trough Android in our previous Android and Arduino Hello World Tutorial, and now we'll understand how to exploit bidirectional communication capabilites in Android environment. First, let's clear what is bidirectional communication: trivially speaking, we have bidirectional communication patterns when both Android and Arduino Compatible Sam3X (in this particular scenario, but the principle is valid also elsewhere) talk to each other, both sending and receiving data. So, let's start! In this tutorial we just use the exact same code of\u00a0\u00a0Android and Arduino Hello World Tutorial, plus adding the readings from a \u00a0Sharp 0A41SK\u00a0ping IR sensor (which you may suspect we love so much, since we used it also here and here\u00a0). UDOOArduinoADKDemoBidirectional.ino First we connect our Ping IR Sensor, you can use the reference wiring shown here\u00a0and edit our Arduino Sketch to read distance readings and send it via OTG. So, in the Arduino sketch we add code to read values from the analog sensor, cut off the outlier values to cut the noise for this specific sensor, and send the bytes with adk method write() distance = analogRead(IR_PIN); if (distance &amp;lt; 100) { \u00a0 \u00a0\u00a0\u00a0\u00a0distance = 100; \u00a0 } else if (distance &amp;gt; 900){ \u00a0\u00a0\u00a0\u00a0distance = 900; } bufWrite[0] = (uint8_t)(2076\/(distance - 11) + 4); \u00a0\/\/ calculate the distance in centimeters adk.write(sizeof(bufWrite), (uint8_t *)bufWrite); \/\/ write the distance to Android \u00a0 MainActivity.java Then we edited the Android app adding a piece of \u00a0code that reads the messages received from the Arduino sketch and display them in a textview. The activity start an AsyncTask to set up the reading from Arduino in another thread, avoiding to lock the main UI thread. &nbsp; ... @Override public void onResume() { super.onResume(); mAdkManager.open(); mAdkReadTask = new AdkReadTask(); mAdkReadTask.execute(); } \/* * We put the readSerial() method in an AsyncTask to run the * continuous read task out of the UI main thread *\/ private class AdkReadTask extends AsyncTask&lt;Void, String, Void&gt; { private boolean running = true; public void pause(){ running = false; } protected Void doInBackground(Void... params) { while(running) { publishProgress(mAdkManager.readSerial()) ; } return null; } protected void onProgressUpdate(String... progress) { distance.setText((int)progress[0].charAt(0) + &quot; cm&quot;); } } ... That's it! As you can see, this is quite a trivial example. Take it as a little suggestion, we're sure you can unleash all your creativity and create amazing projects with this basic principle! If you just want to take a look at the complete code, feel free to land on our Git repository.","tags":"","url":"Cookbook_Android\/Android_And_Arduino_Bidirectional_Communication.html"},{"title":"Face Recognition And Face Tracking Via OpenCV And UDOO","text":"Overview Visit our Tutorials section to learn more about: Face Recognition And Face Tracking Via OpenCV And UDOO.","tags":"","url":"Projects_Examples\/Face_Recognition_And_Face_Tracking_Via_OpenCV_And_UDOO.html"},{"title":"Remote Metereological Station With UDOO","text":"Part 1 Visit our Tutorials section to learn more about: Remote Meteorological Station With UDOO - Pt.1: Sensors &amp; LEDs. Part 2 Visit our Tutorials section to learn more about: Remote Meteorological Station With UDOO - Pt.2: Webserver, PHP &amp; Python.","tags":"","url":"Projects_Examples\/Remote_Metereological_Station_With_UDOO.html"},{"title":"DIY NAS With Openmediavault And UDOO","text":"Part 1 Visit our Tutorials section to learn more about: DIY NAS With Openmediavault And UDOO - Pt.1: Hardware. Part 2 Visit our Tutorials section to learn more about: DIY NAS With Openmediavault And UDOO - Pt.2: Software Overview. Part 3 Visit our Tutorials section to learn more about: DIY NAS With Openmediavault And UDOO - Pt.3: Hardware Setup.","tags":"","url":"Projects_Examples\/DIY_NAS_With_Openmediavault_And_UDOO.html"},{"title":"Setup development environment","text":"The recommended OS for developing UDOO is Ubuntu. If you do not use Ubuntu, you will need to install a virtual machine, as indicated in this section. If you are already running Ubuntu on your development computer, you can safely skip this section. Overview In this section we provide a guide to setup a clean and dedicated environment for UDOO Development as: compile kernel compile MQX libraries Download resources Virtual Machine Player VMWare Download Section VMware Workstation Player Operating System Ubuntu Desktop Download Page Installation VMware Ubuntu 14.04 32 bit Open VMware Player and choose &quot;Create a New Virtual Machine&quot; Select &quot;installer disc image (iso)&quot; option and Browse the Ubuntu 14.04 32 image. Click Next. Choose the user full name, username and password. Choose the Virtual machine name and its location. It's recommended to put it into a drive with 30GB free at least. Choose the maximum virtual hard disk size (20 GB is ok) but 30 is recommended. Space is allocated when is needed. Customize hardware. Depending on your host computer choose the amount of ram memory. 1GB should be ok, but 2 is better :) You can also choose the number of dedicated cores. Don't use all the cores for the virtual machine or you host will become unstable. Select OK and then Next. Installation process will start. Insert your password. Now you should access to a Ubuntu 14.04 desktop. Launch the Virtual Machine Install VMware tools If the system ask for install VMware tools we suggest to accept. It provides useful tools like, window resize and direct copy feature. Update the system Open a terminal. sudo apt-get update","tags":"","url":"Advanced_Topics\/Setup_development_environment.html"},{"title":"Compile UDOObuntu (complete bootable image)","text":"Overview Note: The following instructions are referred to a Linux system. A bootable SD card has 3 different elements: U-Boot (Universal Bootloader) Linux Kernel File System (e.g: UDOObuntu) To create a complete UDOObuntu OS image with these three elements compiled from source you can use the mkudoobuntu script. This could be a useful starter point to create also other distros. mkudoobuntu mkudoobuntu creates SD-card images for UDOO QUAD-DUAL. It supports both desktop and headless images. The created images are as small as possible and expanded to the whole card size during the first boot. This script use Debootstrap to compile Ubuntu 14.04 LTS file system and the others UDOO github repos to compile the UDOO's Linux Kernel and U-Boot. This script has been tested on Ubuntu 15.10, 15.04 and 14.04. It may work on other Debian-like system. Download the latest mkudoobuntu revision from GitHub: git clone https:\/\/github.com\/UDOOboard\/mkudoobuntu.git cd mkudoobuntu To debootstrap a new image with a desktop environment(LXDE) use: sudo .\/mkudoobuntu.sh udoo-qdl desktop To have a new image minimal without any GUI use: sudo .\/mkudoobuntu.sh udoo-qdl minimal You can find more info and commands about this script directly on the Github repo. Once the script finished you can find the .img file in the main mkudoobuntu folder. You can create a bootable microSD from the .img file following this guide: creating a bootable Micro SD card from precompiled image.","tags":"","url":"Advanced_Topics\/Compile_UDOObuntu_(complete_bootable_image).html"},{"title":"Compile U-Boot Bootloader","text":"From the Wikipedia page, the free encyclopedia Das U-Boot (Universal Bootloader) is an open source, primary boot loader used in embedded devices to package the instructions to boot the device's operating system kernel. It is available for a number of computer architectures, including 68k, ARM, AVR32, Blackfin, MicroBlaze, MIPS, Nios, SuperH, PPC and x86. UDOO QUAD-DUAL ARM boards use Das U-Boot. This bootloader initializes the system, and loads kernel and file system to boot the OS. Install the required packages Some packages are needed to compile the U-Boot for UDOO boards. E.g. in Ubuntu 14.04 it is necessary to install the following packages: sudo apt-get update sudo apt-get install gawk wget git diffstat unzip texinfo gcc-multilib \\ build-essential chrpath socat libsdl1.2-dev xterm picocom ncurses-dev lzop \\ gcc-arm-linux-gnueabihf Get the kernel sources from GitHub Download the latest U-Boot revision from GitHub: git clone https:\/\/github.com\/UDOOboard\/uboot-imx cd uboot-imx To build the U-Boot for UDOO Quad\/Dual, use the 2015.10.fslc-qdl branch. This branch is based on NXP\u2122\/Freescale U-Boot Community fork project. git checkout 2015.10.fslc-qdl Compile sources The build can be started with: ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make udoo_qdl_defconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make The produced files, SPL and u-boot.img, can be used to boot both Quad and Dual boards. Flash\/Install the U-Boot on a microSD Unmount all the Micro SD partitions: sudo umount \/dev\/&lt;user_name&gt;\/boot sudo umount \/dev\/&lt;user_name&gt;\/rootfs NOTE: Be sure you\u2019 re using the correct device filename (\/dev\/sdX or \/dev\/mmcblkX); use of the wrong device identifier could result in the loss of all data on the Hard Drive of the host PC used. Double check the filename of your device with command: lsblk Flash the files in the SD (e.g. \/dev\/sdb) card with: sudo dd if=SPL of=\/dev\/mmcblk0 bs=1K seek=1 sudo dd if=u-boot.img of=\/dev\/mmcblk0 bs=1K seek=69","tags":"","url":"Advanced_Topics\/Compile_U_Boot_Bootloader.html"},{"title":"Compile Linux Kernel","text":"Install the required packages Some packages are needed to compile the Linux Kernel for UDOO boards. E.g. in Ubuntu 14.04 it is necessary to install the following packages: sudo apt-get update sudo apt-get install gawk wget git diffstat unzip texinfo gcc-multilib \\ build-essential chrpath socat libsdl1.2-dev xterm picocom ncurses-dev lzop \\ gcc-arm-linux-gnueabihf Get the kernel sources from GitHub Create a develop folder mkdir udoo-dev cd udoo-dev then download the sources: git clone https:\/\/github.com\/UDOOboard\/linux_kernel cd linux_kernel The default branch 3.14-1.0.x-udoo is the one where we are working on for the UDOO QUAD\/DUAL. It is based on 3.14.56 Freescale community kernel. Load the default kernel configuration UDOO QUAD\/DUAL has a dedicated default kernel configuration that you can import with: ARCH=arm make udoo_quad_dual_defconfig (optional) Personalize the kernel configuration Add or remove kernel modules to fit your project: ARCH=arm make menuconfig Compile sources To build the kernel image, type: ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make zImage -j5 You can safely tweak the -jX parameter. For instance, on quad core CPUs with two threads per core, you can use -j8. The build can take several minutes, approximately from 2 to 15, depending on your PC host or VM configuration. [...] Kernel: arch\/arm\/boot\/Image is ready LZO arch\/arm\/boot\/compressed\/piggy.lzo CC arch\/arm\/boot\/compressed\/decompress.o CC arch\/arm\/boot\/compressed\/string.o SHIPPED arch\/arm\/boot\/compressed\/hyp-stub.S SHIPPED arch\/arm\/boot\/compressed\/lib1funcs.S SHIPPED arch\/arm\/boot\/compressed\/ashldi3.S SHIPPED arch\/arm\/boot\/compressed\/bswapsdi2.S AS arch\/arm\/boot\/compressed\/hyp-stub.o AS arch\/arm\/boot\/compressed\/lib1funcs.o AS arch\/arm\/boot\/compressed\/ashldi3.o AS arch\/arm\/boot\/compressed\/bswapsdi2.o AS arch\/arm\/boot\/compressed\/piggy.lzo.o LD arch\/arm\/boot\/compressed\/vmlinux OBJCOPY arch\/arm\/boot\/zImage Kernel: arch\/arm\/boot\/zImage is ready Compile Device Trees ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make dtbs -j5 Compile the modules ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make modules -j5 Copy the kernel to the SD card You can overwrite the kernel on a UDOObuntu SD card with the following commands: BOOT_PARTITION=\/path\/to\/boot-partition ROOT_PARTITION=\/path\/to\/root-partition cp arch\/arm\/boot\/zImage $BOOT_PARTITION cp arch\/arm\/boot\/dts\/*.dtb $BOOT_PARTITION\/dts ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make firmware_install modules_install INSTALL_MOD_PATH=$ROOT_PARTITION","tags":"","url":"Advanced_Topics\/Compile_Linux_Kernel.html"},{"title":"Compile Android From Source","text":"This describes the necessary steps to start and use the pre-compiled Android software support package for UDOO DUAL\/QUAD Board. Moreover, a description of how to rebuild the bootloader, kernel and Android file system is provided. The procedure described in this wiki refers to UDOO DUAL\/QUAD. System Requirements Android system for UDOO DUAL\/QUAD board is provided as precompiled images or as source code to be customized and rebuilt. Running the full procedure described in this wiki, rebuilding the Android system from source files, it is necessary to have an host PC (or Virtual Machine) running Ubuntu Linux 14.04 64bit with at least 40 GB of free disk space, configured in the set up the work environment section below. The host PC should also include: an SD\/\u00b5SD card reader; an host pc with internet connection; a microUSB cable to connect UDOO DUAL\/QUAD to host and access debug serial (optional); Terminology The set of scripts and images necessary to run Android on a board is generically called a Distro. Setting up a Linux build environment Regarding the development environment, you need to first make sure to comply with the AOSP (Android Open Source Project) requirements. Note that it requires a 64-bit version of Linux. Follow this official link for Establishing a Build Environment. We suggest to use a Virtual Machine environment to create a close and dedicated workspace. It reduce risks of procedure and libraries mismatching or to corrupt other working enviroments present on the host machine. Building 5.x Lollipop and 6.0.x Marshmallow versions for UDOO QUAD\/DUAL only requires to have OpenJDK v7 (the v8 as specified in the official Android docs is required only to compile the next Android N). ~$ sudo apt-get install openjdk-7-jdk The packages needed to build the AOSP In addition to the AOSP requirements, the following packages are needed to build NXP\/Freescale components: ~$ sudo apt-get install uuid uuid-dev zip lzop gperf zlib1g-dev \\ liblz-dev liblzo2-2 liblzo2-dev u-boot-tools lib32z1 flex git-core \\ curl mtd-utils android-tools-fsutils At this page you can find how to create a Virtual Machine for Development. Remember you need a 64 bit Linux Distro to compile Android. Serial communication While not exactly necessary, serial communication with UDOO DUAL\/QUAD is strongly recommended as the first debug method. In order to use the serial debug port on UDOO DUAL\/QUAD, after connecting the board and host PC ports, it is necessary to install and setup an application for serial communication, such as minicom. At this page you can find how to Conecting via Serial Cable. The serial debug port is used for two different reasons: The bootloader and kernel send debug messages via serial port, so that the user can monitor the low level system state; a root console is opened on the serial port, allowing bootloader configuration and system control. The number of messages sent via serial port can be very high. For this reason, it is quite useful to increase scrolling capabilities of the terminal, possibly setting them to a very high or even unlimited. Download the source code Next step is downloading the source code. To do so you need the repo tool which has been developed especially for Android in order to manage the hundreds of Git repositories this project contains: ~$ cd ~ ~$ mkdir myandroid bin ~$ curl http:\/\/commondatastorage.googleapis.com\/git-repo-downloads\/repo &gt; ~\/bin\/repo ~$ chmod a+x ~\/bin\/repo ~$ cd myandroid ~$ ~\/bin\/repo init -u https:\/\/github.com\/UDOOboard\/android_udoo_platform_manifest -b android-6.0.1 ~$ ~\/bin\/repo sync -j5 N.B. the repo sync loads the repos needed. Therefore, it can take several hours to load. The -jN command run N tasks at the same time to speed up this process. Configure the environment Prior to build the system, it is necessary to configure the Android environment for the specific build. In particular, the following commands have to be launched: ~$ export ARCH=arm ~$ source build\/envsetup.sh Finally, it is necessary to choose which target to build. The command below shows a list of possible targets ~$ lunch For each possible target, the first part of the name indicates the board you are building for, while the second part selects the build type, as described here. In particular, valid options to build for UDOO DUAL\/QUAD board are: udoo_6dq-user: build for production, with limited access udoo_6dq-eng: build for development, with root access and additional debugging tools The target selection can alternatively be done directly at command line, calling for example ~$ lunch udoo_6dq-eng Once all these steps are done, several environment variables are set. Among the rest, it is worth noting the environment variable OUT, automatically set to udoo-android-dev]\/out\/target\/product\/udoo_6dq, that is the folder where Android system is actually built, and where object files, folders and system images are created. From now on, this folder is called [OUT]. Build Android system image The easiest but most time-consuming step in building Android is to build the Android system image. In general, after configuring the environment as in configuration section, it is sufficient to launch the following command (from the main folder [udoo-android-dev]) to build the whole system image, including the kernel: The code: ~$ make The duration of the whole system build is strongly dependent on the host PC you are working on, but this can take up to several hours, and builds more than 20GB of compiled code (this is the size of the [udoo-android-dev]\/out\/ folder when the operation is completed). Enabling parallel compilation can speed up the process. In general, the idea is to let the compiler to launch several compiling jobs in parallel, where the number of jobs depends on the specific PC you are working on. ~$ make -jN where N is the maximum number of parallel jobs allowed. For a better explanation of this point (included the value to assign to N), please consult http:\/\/source.android.com\/source\/building.html, in Build the Code section above. Several files and folders are created in [OUT]. Among the rest we underline: root\/ and ramdisk.img: root file system and generated image recovery\/ and ramdisk-recovery.img: root file system used in recovery mode, and generated image system\/ and system.img: Android system including binaries and libraries, and generated image data\/ and userdata.img: Android data area and generated image kernel and uImage: kernel images boot.img: kernel and initial root ramdisk, generated from kernel and ramdisk.img recovery.img: kernel and initial root ramdisk used in recovery mode, generated from kernel and ramdisk-recovery.img u-boot.imx: the U-Boot bootloader. This is the first executed binary that loads the kernel and all the system. The images are sufficient to boot UDOO DUAL\/QUAD board with the default kernel configuration. Create a microSD from the Android built files Once the new Android system images are created, it is necessary to prepare a \u00b5SD card with the images and boot UDOO DUAL\/QUAD board. A script is provided to help with this step. In a way similar to what is described in the Run Android section, the script will partition and format the SD card and then copies the new Android images into the correct partitions, reading them directly from [$OUT]. It is sufficient to follow the next steps. Connect the SD card to your host PC, and use the dmesg or fdisk -l commands to find the device name; we suppose in this case it is \/dev\/sdc. Heads up! Please be careful to select the correct microSD device identifier; if you use the wrong identifier you may lose all data in your PC! Launch the script to prepare the SD ~$ cp make_sd.sh $OUT ~$ cd $OUT ~$ sudo -E .\/make_sd.sh \/dev\/sdc When this is done, the SD card containing the images is ready to boot UDOO DUAL\/QUAD as described in the Boot Android from SD section. Prepare a Distro It is sometimes useful to prepare a new Distro to be stored. To do this, once the new images are built following the procedures described in the previous Sections, it is sufficient to call the command ~$ .\/prepare_distro.sh [distro_name] The script creates a new folder [distro_name], containing the freshly built Android system images, and the scripts to use them. An archive [distro_name].tar.gz is also prepared for distribution. Once the archive is ready, you can follow the above section to create a microSD from the Android built files. Boot Android from microSD When the make_sd script ends, insert the SD into the SD card slot and power up the device. The Android system boots. You can see the Android bootscreen on a connected HDMI monitor within 20 seconds, while messages on the serial debug port start to be sent almost immediately. First of all, messages from the bootloader can be seen. Among the rest, characteristics of the board are shown: CPU type, boot device and memory size. Please check the correctness of this information. The kernel is automatically launched after a 3 second countdown. The first time Android System boots, it must configure the storage amd prepare folders for data and applications. As a consequence, every time the SD is prepared with the procedure described in this section, the first boot takes around 1 minute, while subsequent boots are much faster. At the end of the boot procedure, you can interact with the system either with mouse and keyboard and the HDMI display, or with a root console automatically opened in serial. Build Kernel The kernel is built together with the rest of the Android system. However, it is also possible to modify the configuration and rebuild it separately. As for the bootloader, the kernel can be configured and customized for a very wide range of boards and peripherals. Linux kernel customization is a very complex task, an in-depth description is out of the scope of this document. Here we consider only the default configuration to run linux kernel on UDOO DUAL\/QUAD board. It is possible to configure (or restore) the kernel to the default configuration for the Module calling the command below: The command: ~$ make -C kernel_imx udoo_quad_dual_android_defconfig If you wish to check the configuration or customize it, use ~$ make -C kernel_imx menuconfig The command opens a graphical configuration tool. Any saved change is stored in the same folder as an hidden file called .config, which then is the actual configuration file used to compile the kernel. Once the configuration is ready, the kernel is compiled with command ~$ make bootimage This operation can take up to 30 minutes to complete, and performs several actions: builds the kernel, creating the images uImage and zImage in [udoo-android-dev]\/kernel_imx\/arch\/arm\/boot copies the kernel images in [OUT] (zImage is renamed to kernel) updates root\/ and ramdisk.img updates boot.img from ramdisk.img and kernel When it is done, the new boot.img is present in [OUT], ready to be used to boot the Module. Android Build system caches most of the file compiled, sometimes it may happen that some changes aren't reported in the final compiled boot.img. If this happens we suggest to delete from the $OUT folder these file: boot.img, kernel, obj\/KERNEL_OBJ\/* in order to recompile all the Kernel.","tags":"","url":"Advanced_Topics\/Compile_Android_From_Source.html"},{"title":"Install A Custom Debian Distro With Debootstrap","text":"Prerequisites A SD card for the resulting system (1GB or larger) Official UDOO DUAL\/QUAD Kernel and Modules for your model https:\/\/www.udoo.org\/downloads\/ U-boot for your model https:\/\/www.udoo.org\/downloads\/ Debian or Linux OS for creating the install Required software (Available through apt-get) binfmt-support qemu-user-static debootstrap I'm going to use \/dev\/sdb to represent the SD card and ~\/deb as the directory I'm building Debian in. You can also use a SATA disk instead of an SD card, if using a SATA disk, it is even possible to build the system entirely on the UDOO DUAL\/QUAD. Also, with SATA be sure to setup U-Boot. Substitute these with your own paths as needed. First, you need to partition the SD card. Leave room before the primary partition to place uboot. Uboot needs to start at offset 1024B. Here is an example SD card layout, as displayed by fdisk: Device Boot Start End Blocks Id System \/dev\/sdb1 16065 13414274 6699105 83 Linux (units: 512B sectors) You can format and mount the Linux partition with: # mkfs.ext3 \/dev\/sdb1 # mount \/dev\/sdb1 \/mnt You could also mount your device to ~\/dev is you want to build directly on a SD card or SATA disk. Flash U-Boot by running the following command: (This is required to be on the SD even if using SATA) (Replace u-boot-q.bin with the name of the U-Boot file you downloaded) dd if=u-boot-q.bin of=\/dev\/sdb bs=512 seek=2 skip=2 NOTE: We are using \/dev\/sdb here, NOT sdb1, Also, be sure sdb is the sd card Bootstrapping Debian First Stage First, lets create our working directory # mkdir ~\/deb Then we can run the first stage of installing Debian # debootstrap --foreign --arch=armhf wheezy ~\/deb NOTE: For soft-float use --arch=armel instead Once that completes we are almost ready for the second stage, but before we do that, we must copy qemu's arm binary to the new distro. This will allow us to chroot into the new system. # cp \/usr\/bin\/qemu-arm-static ~\/deb\/usr\/bin\/ Second Stage Now, we install the second stage # chroot ~\/deb \/debootstrap\/debootstrap --second-stage This will chroot into the new system and complete the install. You can optionally remove qemu-arm-static from the new install at this point. Now its time to install the kernel # cp path\/to\/uImage ~\/dev\/boot # cd ~\/deb # tar xzf path\/to\/modules.tar.gz Note: replace path\/to with the path where you placed the kernel and modules. If using SATA, be sure to place uImage on the SD card also. Otherwise you will not be able to boot. Post install changes We now have a working Debian system that will boot, however, we will not have networking. chroot into the system: # chroot ~\/deb edit etc\/network\/interfaces to add the eth0 interface # nano \/etc\/network\/interfaces auto eth0 iface eth0 inet dhcp also, edit the bottom of \/etc\/inittab if you want a serial terminal T1:23:respawn:\/sbin\/getty -L ttymxc1 115200 vt100 You may also apt-get any additional packages, once on an SD card, write performance is usually slower. Packages you may want openssh-server for SSH firmware-ralink for the wifi wpasupplicant for wifi connections lxde or xfce for a desktop enviroment tightvncserver for remote desktop git because who DOESN'T download from git? bluetooth for bluetooth support Once done, exit the chroot. Transfer to SD card If you chose to build the system directly on SD or SATA you can skip this step. Now we can copy the new system to your sd card or SATA disk. # cd ~\/deb\/ # cp -rp * \/mnt\/ Once complete its now time to boot! Boot! Now the system is ready for booting! You should already have all the drivers you need for the hardware, some like bluetooth, may require additional software. This guide has been adapted from the guide over at the Freescale community. Binary Tarball Binary tarballs are available below: debian_wheezy_armhf_base system http:\/\/down.ags131.us\/udoo_debian_wheezy.tgz debian_wheezy_armel_lxde system http:\/\/down.ags131.us\/debian_wheezy_armel_lxde.tgz just download it and tar xzf udoo_debian_wheezy.tgz inside your sdcard, SATA disk or staging directory rather than going through debootstrap user is root password is debian LXDE Downloads have vnc autostarted :1 pass is debian","tags":"","url":"Advanced_Topics\/Install_A_Custom_Debian_Distro_With_Debootstrap.html"},{"title":"Boot process","text":"When the board is powered on, the CPU executes code in its internal ROM, loading the first sectors of the SD card. In this way the U-Boot boot-loader is loaded and executed. The boot-loader This thin layer of software takes care of initialize some registers, devices (like the PMIC) and RAM time settings. It is composed of two stages, the first is called SPL (secondary program loader) which initializes several things: arch_cpu_init() initializes some registers, the watchdog, the DMA, etc; ccgr_init initializes CCGR registers in the CCM (Clock Controller Module); board_early_init_f initializes the M4 core and the pads of the UART1; timer_init initializes CPU timers and clock sources; preloader_console_init initializes serial port communications and prints the message &quot;U-Boot SPL 2015.04-00267-gd781468 (Dec 16 2015 - 14:44:56)&quot;; spl_dram_init sets board-specific DRAM configuration (UDOO Neo Basic has 512MB of RAM and different timings); memset zeros BSS memory; board_init_r continues the boot, loading the second stage of the boot-loader. In the second stage, more devices and registers are initialized. I2C buses, LVDS, Ethernet, Wireless and motions sensors pads are initialized. The PFUZE3000 power regulator is setup and MMC is initialized so files can be read from it. The uEnv.txt file Once the hardware is correctly initialized, the uEnv.txt file is read from the FAT \/boot partition. This file contains a few options to override some default settings, like the main video output (which defaults to HDMI). Variable name Default value Possible values video_output hdmi hdmi, lvds7, disabled m4_enabled true true, false use_custom_dtb false true, false Those variables (screen type, M4 core status and the use of custom device tree) are used to select the correct device tree file to load. Linux kernel boot The last step is to load the Linux kernel zImage and the device tree file, both from the \/boot partition: reading \/zImage 4376112 bytes read in 232 ms (18 MiB\/s) Booting from mmc ... reading dts-overlay\/imx6sx-udoo-neo-full-hdmi-m4.dtb 45210 bytes read in 35 ms (1.2 MiB\/s) Kernel image @ 0x80800000 [ 0x000000 - 0x42c630 ] ## Flattened Device Tree blob at 83000000 Booting using the fdt blob at 0x83000000 Using Device Tree in place at 83000000, end 8300e099 Switched to ldo_bypass mode! Starting kernel ... [ 0.000000] Booting Linux on physical CPU 0x0 [ 0.000000] Linux version 3.14.56-udooneo-01989-.....","tags":"","url":"Advanced_Topics\/Boot_process.html"},{"title":"Mod Your UDOO To Improve WiFi Performances","text":"Overview Visit our Tutorials section to learn more about: Mod Your UDOO To Improve Wi-Fi Performances.","tags":"","url":"Mods\/Mod_Your_UDOO_To_Improve_WiFi_Performances.html"},{"title":"Introductive","text":"What is a single board computer? A single-board computer (SBC) like UDOO DUAL\/QUAD or Raspberry Pi is a complete computer built on a single circuit board, with microprocessor(s), memory, input\/output (I\/O) and other features of a functional computer. Which people use single board computers like UDOO QUAD\/DUAL? Students and teachers, designers, startups, industries, research groups: all of them are average users of single board computers like UDOO DUAL\/QUAD. They are called Makers. You can be a Maker too. Everybody can be a Maker. Why people use single board computers like UDOO QUAD\/DUAL? People use UDOO QUAD\/DUAL for three purposes: a) like a pocket low-cost low-power consumption computer; b) like an Arduino; c) like a computer designed to be embedded on things, ideal for creative projects. Why should I use a single board computer instead of a laptop computer? They are two different things. Single board computers are perfect to be embedded on things and devices, like a piece of puzzle. If you want to build a rover, a Photobooth or you just want to hack your car, you can't do it with your computer: it's too big, too heavy, too high power-consumption, and lack GPIOs. What is a microcontroller? A microcontroller is a small computer, designed for specificied and\/or light tasks, built on a single integrated circuit containing a processor core, memory, and programmable input\/output peripherals. The most famous microcontroller is Arduino, the pioneer of the Maker movement. What is Arduino? Arduino is an open-source microcontroller. Arduino is so great because with Arduino you can tinker and realize cool stuff without being an engineers. Arduino is a powerful tool, and that's why we designed UDOO QUAD\/DUAL to be Arduino-compatible. What is a jumper? A jumper is a short length of conductor used to close a break in or open, or bypass part of, an electrical circuit. On UDOO QUAD\/DUAL jumpers are signed. Which are the jumpers of UDOO QUAD\/DUAL and what should I use them for? Jumpers of UDOO QUAD\/DUAL are: J2, J16, J18, J22. Every jumper has a different purpose. If you keep J18 plugged, you are talking with the i.MX 6 processor and, for example, you can see the console during the boot and talk with the u-boot, stopping it, for example. If you unplug J18, you instead talk with SAM3X8E. By plugging and unplugging J22 you can erase the Arduino sketch you have written: it means you have to reflash your MicroSD. By plugging and unplugging J16, you reset the Arduino: it means your sketch will restart from setup J2 enables OTG power supply. Keep it plugged to enable the power supply on the OTG port. What is a serial? You will read many times about &quot;serials&quot; in the Forum. &quot;Serial&quot; stands for &quot;serial cable&quot;: a cable used to transform the information between two devices using a serial communication protocol.","tags":"","url":"FAQ\/Introductive.html"},{"title":"Why My UDOO Wont Boot","text":"If your UDOO DUAL\/QUAD doesn't boot, you first need to: Wait at least 2 minutes: right now there is no feedback during the boot process, only a black screen; Check the MicroSD Card and try to reflash it with a proper version, or use a different OS; Try with a new MicroSD Card: the one you were using could be corrupted and cannot be restored to proper functionality; Check if you are using the proper power supply and if it provides the right voltage and amperage. To do so, check with a multimeter if the output voltage sits between 6 and 15V and at least 1A; After plugging the PSU cable, try to hit the reset button. If the board still doesn't boot you need to verify if your OS actually starts using a serial debug connection. This allows a more complete analysis of your situation. To establish a USB Debug connection follow these easy steps on our Docs. Once you're ready, power up your UDOO DUAL\/QUAD and look at the serial output: 1- If the Serial returns the following output (after 30 seconds) the OS was correctly loaded by UDOO DUAL\/QUAD. Everything works just fine, the problem could be in the HDMI cable, in your display or your UDOO DUAL\/QUAD probably needs a patch that will solve a HDMI problem we encountered in some UDOO DUAL\/QUAD. The patch will be available soon. 2- If the Serial returns the following output or similar: The OS is corrupted which means and error occurred during the download or the flashing process of the image. In this case verify the validity of the image using the related SHA1 you can find in the download section of www.udoo.org and try to rewrite the image on your MicroSD. 3- If the Serial returns the following output: You may experiencing a HDMI issues. To solve the problem, check the troubleshooting guide: How can I solve my HDMI issues? Don't forget however to check your HDMI cable connection, maybe something wasn't plugged properly. 4- If the Serial returns nothing: The image wasn't correctly flashed (e.g. was written in a partition) or you selected a wrong image in the download section (e.g. a Ubuntu_dual for a UDOO Quad). In this case repeat the procedure of how to write the image on MicroSD.","tags":"","url":"Troubleshooting\/Why_My_UDOO_Wont_Boot.html"},{"title":"How Can I Solve My HDMI Issues","text":"If you can't see anything from your HDMI monitor be sure to follow the why my udoo wont boot guide and have a serial debug connection first. If the Serial returns the following output: Reboot the board and stop the process at U-Boot stage (hit any key to stop autoboot during countdown). For more info see the UDOO DUAL\/QUAD starting manual. To apply the HDMI detect patch you have to execute the following commands: setenv hdmi_patch udoo_hdmi_force_hpdetect saveenv boot this command will reboot the system and, after about 30 seconds, the HDMI monitor should start. If you're able to see the output on your monitor the UDOO DUAL\/QUAD is correctly patched. If not, run this command: dmesg | grep edid if you get the following output mxc_hdmi mxc_hdmi: No nodes read from edid there is a problem in reading the EDID code from HDMI monitor. Reboot the board again and stop the process at U-Boot stage (hit any key to stop autoboot during countdown). For more info see the UDOO DUAL\/QUAD starting manual. Run these commands: setenv hdmi_patch udoo_hdmi_force_hpdetect udoo_hdmi_force_edid saveenv boot Once the system finished booting, run: sudo i2cdump -f -y 1 0x50 That command should dump edid table readed from HDMI display No size specified (using byte-data access) 0 1 2 3 4 5 6 7 8 9 a b c d e f 0123456789abcdef 00: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX 10: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX 20: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX 30: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX 40: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX 50: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX 60: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX 70: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX 80: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX 90: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX a0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX b0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX c0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX d0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX e0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX f0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XXXXXXXXXXXXXXXX This means that the kernel is unable to read the correct information to fit your screen resolution. To do so, you need to find the correct edid.txt file in a different way. Here's an example of a valid edid table to write inside the \/etc\/edid.txt file 00 ff ff ff ff ff ff 00 26 cd 0c 56 6f 1e 00 00 2b 15 01 03 80 34 1d 78 2a 60 41 a6 56 4a 9c 25 12 50 54 bf ef 00 71 4f 81 40 81 80 95 00 95 0f b3 00 01 01 01 01 02 3a 80 18 71 38 2d 40 58 2c 45 00 09 25 21 00 00 1e 00 00 00 fd 00 38 4c 1e 53 11 00 0a 20 20 20 20 20 20 00 00 00 fc 00 50 4c 32 34 30 39 48 44 0a 20 20 20 20 00 00 00 ff 00 31 31 30 37 37 4d 31 41 30 37 37 39 31 01 be 02 03 1f f1 4c 01 02 03 04 05 10 11 12 13 14 1e 1f 23 09 07 01 83 01 00 00 65 03 0c 00 10 00 8c 0a d0 8a 20 e0 2d 10 10 3e 96 00 09 25 21 00 00 18 01 1d 00 72 51 d0 1e 20 6e 28 55 00 09 25 21 00 00 1e 8c 0a d0 90 20 40 31 20 0c 40 55 00 09 25 21 00 00 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 4f By default the patch loads an edid.txt file that should work with 1920x1080 resolution. For different screen resolutions you should retrive the edid.txt file in a different way and then copy it to \/etc\/edid.txt (we are still looking for the right procedure to retrieve your edid configuration). At this url you'll find more information about the edid files.","tags":"","url":"Troubleshooting\/How_Can_I_Solve_My_HDMI_Issues.html"},{"title":"How Do I Set Up My LVDS Panel","text":"With the official UDOObuntu distro using your LVDS is very easy!! Follow these simple steps: Open the &quot;UDOO DUAL\/QUAD configuration tool&quot; you can find in desktop or in the applications top bar. Select &quot;Set Default Video Output (LVDS\\HDMI)&quot;. Select the output video you need. Reboot the system. That's it!!! To use your LVDS with other UDOO DUAL\/QUAD distros you need to follow these instructions: Make sure you have the lastest U-Boot and kernel. If not you can use the simple update procedure. With the last U-Boot version (release 2.1 - v.119) you need to change the &quot;video&quot; environment variables with: 15&quot; --&gt; video=mxcfb0:dev=ldb,1366x768M@60,if=RGB24,bpp=32 7&quot; --&gt; video=mxcfb0:dev=ldb,LDB-WVGA,if=RGB666,bpp=32 hdmi --&gt; video=mxcfb0:dev=hdmi,1920x1080M@60,if=RGB24,bpp=32 (default environment variable) To do this you need to connect an external pc to the debug serial of UDOO DUAL\/QUAD and stop the boot procedure at U-Boot. For more info see the Tutorial connecting via serial cable or the UDOO DUAL\/QUAD starting manual at the \u201cEstablish serial debug connection with UDOO DUAL\/QUAD\u201d section. These are the commands you need to insert in the U-Boot console: \u00a0 15&quot; linux: setenv mmcargs setenv bootargs console=${console},${baudrate} root=${mmcroot} ${hdmi_patch} fbmem=24M video=mxcfb0:dev=ldb,LDB-WXGA,if=RGB24,bpp=32 15&quot; android: setenv bootargs console=ttymxc1,115200 init=\/init video=mxcfb0:dev=ldb,1366x768M@60,if=RGB24,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=28M vmalloc=400M androidboot.console=ttymxc1 androidboot.hardware=freescale mem=1024M 7&quot; linux: setenv mmcargs setenv bootargs console=${console},${baudrate} root=${mmcroot} ${hdmi_patch} fbmem=24M video=mxcfb0:dev=ldb,LDB-WVGA,if=RGB666,bpp=32 7&quot; android: setenv bootargs console=ttymxc1,115200 init=\/init video=mxcfb0:dev=ldb,LDB-WVGA,if=RGB666,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=28M vmalloc=400M androidboot.console=ttymxc1 androidboot.hardware=freescale mem=1024M hdmi linux: setenv mmcargs setenv bootargs console=${console},${baudrate} root=${mmcroot} ${hdmi_patch} fbmem=24M video=mxcfb0:dev=hdmi,1920x1080M@60,bpp=32 hdmi android: setenv bootargs console=ttymxc1,115200 init=\/init video=mxcfb0:dev=hdmi,1920x1080M@60,if=RGB24,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=28M vmalloc=400M androidboot.console=ttymxc1 androidboot.hardware=freescale mem=1024M At the next boot the video source will again be the default one unless you save the configuration you just inserted with the command: saveenv In Android you can also boot UDOO DUAL\/QUAD from both HDMI and LVDS panel at the same time inserting these variables in a different frame buffer: e.g. boot on lvds 7&quot; and hdmi. setenv bootargs console=ttymxc1,115200 init=\/init video=mxcfb0:dev=ldb,LDB-WVGA,if=RGB666,bpp=32 video=mxcfb1:dev=hdmi,1920x1080M@60,if=RGB24,bpp=32 video=mxcfb2:off fbmem=28M vmalloc=400M androidboot.console=ttymxc1 androidboot.hardware=freescale mem=1024M If you have any problem with touch calibration in Linux distros try to modify the text file: \/etc\/X11\/xorg.conf.d\/99-calibration.conf with this text: Section &quot;InputClass&quot; Identifier &quot;calibration&quot; MatchProduct &quot;3M 3M USB Touchscreen - EX II&quot; Option &quot;Calibration&quot; &quot;-75 65106 2318 65008&quot; Option &quot;SwapAxes&quot; &quot;0&quot; Option &quot;InvertX&quot; &quot;1&quot; Option &quot;InvertY&quot; &quot;0&quot; EndSection Section &quot;InputClass&quot; Identifier &quot;calibration&quot; MatchProduct &quot;sitronix-i2c-touch-mt&quot; Option &quot;Calibration&quot; &quot;10 802 11 479&quot; EndSection If the calibration is not good enough you can connect a mouse to UDOO DUAL\/QUAD and launch the &quot;Calibrate Touchscreen&quot; application from the top bar: Application -&gt; System Tools -&gt; Administration -&gt; Calibrate Touchscreen or run in a terminal the command: xinput_calibrator and follow the video instruction to change your calibration.","tags":"","url":"Troubleshooting\/How_Do_I_Set_Up_My_LVDS_Panel.html"},{"title":"Mirroring UDOOs Desktop on your PC with VNC Remote Desktop","text":"If you don\u2019t have a monitor, keyboard and mouse you can still use UDOO DUAL\/QUAD easily at its full potential. You can connect to UDOO DUAL\/QUAD Remote Desktop via VNC. To do that, just follow these steps: Assign a static address to your UDOO DUAL\/QUAD Edit the \/etc\/network\/interfaces file auto lo iface lo inet loopback auto eth0 iface eth0 inet static ip 192.168.137.2 netmask 255.255.255.0 gateway 192.168.137.1 Connect UDOO DUAL\/QUAD to your PC via a Lan Cable Prepare your PC Networking as follows: On Windows: Go to Network Settings, Select your wireless adapter and choose \u201cAdvanced Properties\u201d then Sharing. Share this connection with your Ethernet Adapter, and hit apply. At this point, your pc will have 192.168.137.1 as IP This means that UDOO DUAL\/QUAD will share internet connection trough your PC On Mac OS X: Go to settings, then Network Set your Ethernet adaper as \u201cManual\u201d Insert the following settings IP: 192.168.137.1 NETMASK: 255.255.255.0 GATEWAY: 192.168.137.1 Hit Apply On Linux: Edit your Network interfaces as follows: IP: 192.168.137.1 NETMASK: 255.255.255.0 GATEWAY: 192.168.137.1 And bridge your Wireless connection with Ethernet Establish a remote VNC connection Now you\u2019re ready to power on your UDOO DUAL\/QUAD, make sure the SD Card with UDOOBuntu is inserted. The last step is installing and configuring a VNC Client. On Windows: Download and install RealVNC Viewer for Windows Once opened, insert UDOO DUAL\/QUAD\u2019s IP followed by :5901 (192.168.137.2:5901) Insert the password: ubuntu Done! Browse UDOO DUAL\/QUAD remotely with your Windows machine On Mac OSX: Download and install RealVNC Viewer for Mac Once opened, insert UDOO DUAL\/QUAD\u2019s IP followed by :5901 (192.168.137.2:5901) Insert the password: ubuntu Done! Browse UDOO DUAL\/QUAD remotely with your Mac On Linux Ubuntu: Install via terminal xvnc4viewer sudo apt-get update sudo apt-get install xvnc4viewer Launch xvncviewer with sudo xvncviewer Insert UDOO DUAL\/QUAD\u2019s IP followed by :5901 (192.168.137.2:5901) Insert Server\u2019s Password: ubuntu Done! Browse UDOO DUAL\/QUAD remotely with your Linux machine! More informations can be found at the UDOO VNC Tutorial Page","tags":"","url":"Hackaton_Survival_Guide\/Mirroring_UDOOs_Desktop_on_your_PC_with_VNC_Remote_Desktop.html"},{"title":"Programming UDOOs Arduino from your PC","text":"If you prefer, you can choose to program UDOO DUAL\/QUAD\u2019s Arduino from your PC, these are the required steps. Please note that a working SD Card should be present on UDOO DUAL\/QUAD Unplug J18 jumper This will allow the communication between your computer and the programming port of the SAM3X Connect a Micro USB cable to CN6 serial\/programming port. Install the serial drivers Install the driver for the cn6 MicroUSB port that allows the correct communication between your external computer and UDOO DUAL\/QUAD (choose the correct Operating System of your Computer). Windows MacOsX Linux 3.X Linux 2.6.X Patch the Arduino IDE Now, let\u2019s configure the standard Arduino-IDE in order to make it communicate to the Sam3x of UDOO DUAL\/QUAD. To do it we need to patch the official Arduino IDE: Download and install the Arduino IDE version 1.5 for your specific operating system from Arduino Website (other versions will not work, since UDOO DUAL\/QUAD needs Arduino 2 compabile programming software) Download the patch for your Operating system: Windows MacOsX Linux64 Linux32 Extract the files in the archive and place them in the following paths, overwriting the previous existing files: Windows 32 bit: C:\\Program Files\\Arduino\\hardware\\tools Win 64 bit: C:\\Program Files (x86)\\Arduino\\hardware\\tools Linux: \/hardware\/tools\/ Mac OS X: \/Contents\/Resources\/Java\/hardware\/tools\/ With this patch you are now able to upload your sketch selecting the Arduino Due(Programming Port) from: Tools -&gt; Board and the right port from Tools -&gt; Port in the Arduino IDE","tags":"","url":"Hackaton_Survival_Guide\/Programming_UDOOs_Arduino_from_your_PC.html"},{"title":"Useful Resources","text":"Links Projects: if you are looking for inspiration here is a link to the widest collection of UDOO-based projects out there. Serial Communication Examples: communication beetweeen Linux and Arduino on UDOO OpenCV Face Recognition Tutorial: learn how to use OpenCV and hook it to UDOO\u2019s Arduino","tags":"","url":"Hackaton_Survival_Guide\/Useful_Resources.html"}]}